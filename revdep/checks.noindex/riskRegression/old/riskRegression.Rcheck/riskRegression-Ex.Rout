
R version 4.0.2 (2020-06-22) -- "Taking Off Again"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "riskRegression"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('riskRegression')
riskRegression version 2020.12.08
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("CSC")
> ### * CSC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CSC
> ### Title: Cause-specific Cox proportional hazard regression
> ### Aliases: CSC
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(survival)
> data(Melanoma)
> ## fit two cause-specific Cox models
> ## different formula for the two causes
> fit1 <- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~invasion+epicel+log(thick)),
+             data=Melanoma)
> print(fit1)
CSC(formula = list(Hist(time, status) ~ sex + age, Hist(time, 
    status) ~ invasion + epicel + log(thick)), data = Melanoma)

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
coxph(formula = survival::Surv(time, status) ~ sex + age, x = TRUE, 
    y = TRUE)

  n= 205, number of events= 57 

            coef exp(coef) se(coef)     z Pr(>|z|)  
sexMale 0.598259  1.818949 0.267639 2.235   0.0254 *
age     0.016542  1.016679 0.008663 1.910   0.0562 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

        exp(coef) exp(-coef) lower .95 upper .95
sexMale     1.819     0.5498    1.0765     3.074
age         1.017     0.9836    0.9996     1.034

Concordance= 0.631  (se = 0.037 )
Likelihood ratio test= 9.94  on 2 df,   p=0.007
Wald test            = 10  on 2 df,   p=0.007
Score (logrank) test = 10.26  on 2 df,   p=0.006



----------> Cause:  2 

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    log(thick), x = TRUE, y = TRUE)

  n= 205, number of events= 14 

                   coef exp(coef) se(coef)      z Pr(>|z|)  
invasionlevel.1 -0.7315    0.4812   0.6492 -1.127   0.2599  
invasionlevel.2 -2.2593    0.1044   1.2478 -1.811   0.0702 .
epicelpresent    1.0840    2.9564   0.5738  1.889   0.0589 .
log(thick)       0.8954    2.4484   0.3959  2.262   0.0237 *
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    0.4812     2.0781  0.134806     1.718
invasionlevel.2    0.1044     9.5768  0.009051     1.205
epicelpresent      2.9564     0.3383  0.960134     9.103
log(thick)         2.4484     0.4084  1.126881     5.320

Concordance= 0.648  (se = 0.1 )
Likelihood ratio test= 7.41  on 4 df,   p=0.1
Wald test            = 7.72  on 4 df,   p=0.1
Score (logrank) test = 7.44  on 4 df,   p=0.1

> ## Not run: 
> ##D library(Publish)
> ##D publish(fit1)
> ## End(Not run)
> 
> ## model hazard of all cause mortality instead of hazard of type 2
> fit1a <- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~invasion+epicel+log(thick)),
+              data=Melanoma,
+              surv.type="surv")
> 
> ## the predicted probabilities are similar
> plot(predictRisk(fit1,times=500,cause=1,newdata=Melanoma),
+      predictRisk(fit1a,times=500,cause=1,newdata=Melanoma))
> 
> ## special case where cause 2 has no covariates
> fit1b <- CSC(list(Hist(time,status)~sex+age,Hist(time,status)~1),
+              data=Melanoma)
> print(fit1b)
CSC(formula = list(Hist(time, status) ~ sex + age, Hist(time, 
    status) ~ 1), data = Melanoma)

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
coxph(formula = survival::Surv(time, status) ~ sex + age, x = TRUE, 
    y = TRUE)

  n= 205, number of events= 57 

            coef exp(coef) se(coef)     z Pr(>|z|)  
sexMale 0.598259  1.818949 0.267639 2.235   0.0254 *
age     0.016542  1.016679 0.008663 1.910   0.0562 .
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

        exp(coef) exp(-coef) lower .95 upper .95
sexMale     1.819     0.5498    1.0765     3.074
age         1.017     0.9836    0.9996     1.034

Concordance= 0.631  (se = 0.037 )
Likelihood ratio test= 9.94  on 2 df,   p=0.007
Wald test            = 10  on 2 df,   p=0.007
Score (logrank) test = 10.26  on 2 df,   p=0.006



----------> Cause:  2 

Call:  coxph(formula = survival::Surv(time, status) ~ 1, x = TRUE, y = TRUE)

Null model
  log likelihood= -67.29348 
  n= 205 
> predict(fit1b,cause=1,times=100,newdata=Melanoma)
     observation    sex age times absRisk
  1:           1   Male  76   100       0
  2:           2   Male  56   100       0
  3:           3   Male  41   100       0
  4:           4 Female  71   100       0
  5:           5   Male  52   100       0
 ---                                     
201:         201   Male  29   100       0
202:         202 Female  40   100       0
203:         203 Female  42   100       0
204:         204 Female  50   100       0
205:         205 Female  41   100       0
> 
> 
> ## same formula for both causes
> fit2 <- CSC(Hist(time,status)~invasion+epicel+age,
+             data=Melanoma)
> print(fit2)
CSC(formula = Hist(time, status) ~ invasion + epicel + age, data = Melanoma)

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                     coef exp(coef)  se(coef)      z Pr(>|z|)    
invasionlevel.1  0.935415  2.548270  0.326212  2.868  0.00414 ** 
invasionlevel.2  1.268866  3.556818  0.384273  3.302  0.00096 ***
epicelpresent   -0.824665  0.438382  0.301977 -2.731  0.00632 ** 
age              0.017170  1.017318  0.008795  1.952  0.05092 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    2.5483     0.3924    1.3445    4.8297
invasionlevel.2    3.5568     0.2812    1.6748    7.5536
epicelpresent      0.4384     2.2811    0.2426    0.7923
age                1.0173     0.9830    0.9999    1.0350

Concordance= 0.696  (se = 0.036 )
Likelihood ratio test= 28.72  on 4 df,   p=9e-06
Wald test            = 25.85  on 4 df,   p=3e-05
Score (logrank) test = 28.07  on 4 df,   p=1e-05



----------> Cause:  2 

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    age, x = TRUE, y = TRUE)

  n= 205, number of events= 14 

                    coef exp(coef) se(coef)      z Pr(>|z|)    
invasionlevel.1 -0.91300   0.40132  0.64105 -1.424 0.154381    
invasionlevel.2 -1.27662   0.27898  1.11701 -1.143 0.253086    
epicelpresent    0.32241   1.38045  0.57013  0.566 0.571730    
age              0.09323   1.09772  0.02605  3.579 0.000346 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    0.4013     2.4918   0.11424     1.410
invasionlevel.2    0.2790     3.5845   0.03124     2.491
epicelpresent      1.3804     0.7244   0.45157     4.220
age                1.0977     0.9110   1.04307     1.155

Concordance= 0.83  (se = 0.046 )
Likelihood ratio test= 18.99  on 4 df,   p=8e-04
Wald test            = 14  on 4 df,   p=0.007
Score (logrank) test = 15.03  on 4 df,   p=0.005

> 
> ## combine a cause-specific Cox regression model for cause 2
> ## and a Cox regression model for the event-free survival:
> ## different formula for cause 2 and event-free survival
> fit3 <- CSC(list(Hist(time,status)~sex+invasion+epicel+age,
+                  Hist(time,status)~invasion+epicel+age),
+             surv.type="surv",
+             data=Melanoma)
> print(fit3)
CSC(formula = list(Hist(time, status) ~ sex + invasion + epicel + 
    age, Hist(time, status) ~ invasion + epicel + age), data = Melanoma, 
    surv.type = "surv")

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
coxph(formula = survival::Surv(time, status) ~ sex + invasion + 
    epicel + age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                    coef exp(coef) se(coef)      z Pr(>|z|)    
sexMale          0.81455   2.25817  0.27080  3.008 0.002630 ** 
invasionlevel.1  0.95491   2.59842  0.32593  2.930 0.003392 ** 
invasionlevel.2  1.37028   3.93647  0.38333  3.575 0.000351 ***
epicelpresent   -0.96361   0.38151  0.30587 -3.150 0.001630 ** 
age              0.01624   1.01637  0.00844  1.924 0.054392 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
sexMale            2.2582     0.4428    1.3282    3.8394
invasionlevel.1    2.5984     0.3848    1.3718    4.9220
invasionlevel.2    3.9365     0.2540    1.8570    8.3445
epicelpresent      0.3815     2.6211    0.2095    0.6948
age                1.0164     0.9839    0.9997    1.0333

Concordance= 0.731  (se = 0.036 )
Likelihood ratio test= 37.59  on 5 df,   p=5e-07
Wald test            = 33.68  on 5 df,   p=3e-06
Score (logrank) test = 35.94  on 5 df,   p=1e-06



----------> Event-free survival:

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    age, x = TRUE, y = TRUE)

  n= 205, number of events= 71 

                     coef exp(coef)  se(coef)      z Pr(>|z|)   
invasionlevel.1  0.598823  1.819976  0.280176  2.137  0.03257 * 
invasionlevel.2  0.846287  2.330977  0.345425  2.450  0.01429 * 
epicelpresent   -0.573750  0.563408  0.254760 -2.252  0.02431 * 
age              0.027346  1.027723  0.008348  3.276  0.00105 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    1.8200     0.5495     1.051    3.1517
invasionlevel.2    2.3310     0.4290     1.184    4.5874
epicelpresent      0.5634     1.7749     0.342    0.9283
age                1.0277     0.9730     1.011    1.0447

Concordance= 0.682  (se = 0.032 )
Likelihood ratio test= 27.56  on 4 df,   p=2e-05
Wald test            = 26.15  on 4 df,   p=3e-05
Score (logrank) test = 27.02  on 4 df,   p=2e-05

> 
> ## same formula for both causes
> fit4 <- CSC(Hist(time,status)~invasion+epicel+age,
+             data=Melanoma,
+             surv.type="surv")
> print(fit4)
CSC(formula = Hist(time, status) ~ invasion + epicel + age, data = Melanoma, 
    surv.type = "surv")

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    age, x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                     coef exp(coef)  se(coef)      z Pr(>|z|)    
invasionlevel.1  0.935415  2.548270  0.326212  2.868  0.00414 ** 
invasionlevel.2  1.268866  3.556818  0.384273  3.302  0.00096 ***
epicelpresent   -0.824665  0.438382  0.301977 -2.731  0.00632 ** 
age              0.017170  1.017318  0.008795  1.952  0.05092 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    2.5483     0.3924    1.3445    4.8297
invasionlevel.2    3.5568     0.2812    1.6748    7.5536
epicelpresent      0.4384     2.2811    0.2426    0.7923
age                1.0173     0.9830    0.9999    1.0350

Concordance= 0.696  (se = 0.036 )
Likelihood ratio test= 28.72  on 4 df,   p=9e-06
Wald test            = 25.85  on 4 df,   p=3e-05
Score (logrank) test = 28.07  on 4 df,   p=1e-05



----------> Event-free survival:

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    age, x = TRUE, y = TRUE)

  n= 205, number of events= 71 

                     coef exp(coef)  se(coef)      z Pr(>|z|)   
invasionlevel.1  0.598823  1.819976  0.280176  2.137  0.03257 * 
invasionlevel.2  0.846287  2.330977  0.345425  2.450  0.01429 * 
epicelpresent   -0.573750  0.563408  0.254760 -2.252  0.02431 * 
age              0.027346  1.027723  0.008348  3.276  0.00105 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    1.8200     0.5495     1.051    3.1517
invasionlevel.2    2.3310     0.4290     1.184    4.5874
epicelpresent      0.5634     1.7749     0.342    0.9283
age                1.0277     0.9730     1.011    1.0447

Concordance= 0.682  (se = 0.032 )
Likelihood ratio test= 27.56  on 4 df,   p=2e-05
Wald test            = 26.15  on 4 df,   p=3e-05
Score (logrank) test = 27.02  on 4 df,   p=2e-05

> 
> ## strata
> fit5 <- CSC(Hist(time,status)~invasion+epicel+age+strata(sex),
+             data=Melanoma,
+             surv.type="surv")
> print(fit5)
CSC(formula = Hist(time, status) ~ invasion + epicel + age + 
    strata(sex), data = Melanoma, surv.type = "surv")

Right-censored response of a competing.risks model

No.Observations: 205 

Pattern:
         
Cause     event right.censored
  1          57              0
  2          14              0
  unknown     0            134


----------> Cause:  1 

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    age + strata(sex), x = TRUE, y = TRUE)

  n= 205, number of events= 57 

                     coef exp(coef)  se(coef)      z Pr(>|z|)    
invasionlevel.1  0.962644  2.618612  0.326103  2.952 0.003158 ** 
invasionlevel.2  1.341972  3.826581  0.385085  3.485 0.000492 ***
epicelpresent   -0.966928  0.380249  0.307215 -3.147 0.001647 ** 
age              0.016206  1.016338  0.008442  1.920 0.054916 .  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    2.6186     0.3819    1.3819    4.9619
invasionlevel.2    3.8266     0.2613    1.7990    8.1395
epicelpresent      0.3802     2.6299    0.2082    0.6943
age                1.0163     0.9839    0.9997    1.0333

Concordance= 0.716  (se = 0.036 )
Likelihood ratio test= 31.18  on 4 df,   p=3e-06
Wald test            = 27.78  on 4 df,   p=1e-05
Score (logrank) test = 30.19  on 4 df,   p=4e-06



----------> Event-free survival:

Call:
coxph(formula = survival::Surv(time, status) ~ invasion + epicel + 
    age + strata(sex), x = TRUE, y = TRUE)

  n= 205, number of events= 71 

                     coef exp(coef)  se(coef)      z Pr(>|z|)   
invasionlevel.1  0.638422  1.893491  0.280113  2.279  0.02266 * 
invasionlevel.2  0.921428  2.512877  0.347222  2.654  0.00796 **
epicelpresent   -0.699726  0.496721  0.259302 -2.698  0.00697 **
age              0.025606  1.025937  0.008091  3.165  0.00155 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

                exp(coef) exp(-coef) lower .95 upper .95
invasionlevel.1    1.8935     0.5281    1.0935    3.2787
invasionlevel.2    2.5129     0.3980    1.2724    4.9628
epicelpresent      0.4967     2.0132    0.2988    0.8257
age                1.0259     0.9747    1.0098    1.0423

Concordance= 0.702  (se = 0.031 )
Likelihood ratio test= 28.77  on 4 df,   p=9e-06
Wald test            = 27.35  on 4 df,   p=2e-05
Score (logrank) test = 28.17  on 4 df,   p=1e-05

> 
> ## sanity checks
> 
> cox1 <- coxph(Surv(time,status==1)~invasion+epicel+age+strata(sex),data=Melanoma)
> cox2 <- coxph(Surv(time,status!=0)~invasion+epicel+age+strata(sex),data=Melanoma)
> all.equal(coef(cox1),coef(fit5$models[[1]]))
[1] TRUE
> all.equal(coef(cox2),coef(fit5$models[[2]]))
[1] TRUE
> 
> ## predictions
> ##
> ## surv.type = "hazard": predictions for both causes can be extracted
> ## from the same fit
> fit2 <- CSC(Hist(time,status)~invasion+epicel+age, data=Melanoma)
> predict(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
   observation invasion      epicel age times absRisk
1:           1  level.1 not present  46   100  0.0000
2:           2  level.1 not present  34   100  0.0000
3:           3  level.0     present  58   100  0.0000
4:           1  level.1 not present  46  1000  0.1928
5:           2  level.1 not present  34  1000  0.1603
6:           3  level.0     present  58  1000  0.0427
7:           1  level.1 not present  46 10000      NA
8:           2  level.1 not present  34 10000      NA
9:           3  level.0     present  58 10000      NA
> predictRisk(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
     [,1]       [,2] [,3]
[1,]    0 0.19283566   NA
[2,]    0 0.16026171   NA
[3,]    0 0.04268555   NA
> predictRisk(fit2,cause=2,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
             [,1]        [,2] [,3]
[1,] 0.0018172532 0.004281110   NA
[2,] 0.0005938955 0.001411264   NA
[3,] 0.0190247785 0.045781785   NA
> predict(fit2,cause=1,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
   observation invasion      epicel age times absRisk
1:           1  level.1 not present  46   100  0.0000
2:           2  level.1 not present  34   100  0.0000
3:           3  level.0     present  58   100  0.0000
4:           1  level.1 not present  46  1000  0.1928
5:           2  level.1 not present  34  1000  0.1603
6:           3  level.0     present  58  1000  0.0427
7:           1  level.1 not present  46 10000      NA
8:           2  level.1 not present  34 10000      NA
9:           3  level.0     present  58 10000      NA
> predict(fit2,cause=2,newdata=Melanoma[c(17,99,108),],times=c(100,1000,10000))
   observation invasion      epicel age times  absRisk
1:           1  level.1 not present  46   100 0.001817
2:           2  level.1 not present  34   100 0.000594
3:           3  level.0     present  58   100 0.019025
4:           1  level.1 not present  46  1000 0.004281
5:           2  level.1 not present  34  1000 0.001411
6:           3  level.0     present  58  1000 0.045782
7:           1  level.1 not present  46 10000       NA
8:           2  level.1 not present  34 10000       NA
9:           3  level.0     present  58 10000       NA
> 
> ## surv.type = "surv" we need to change the cause of interest
> library(survival)
> fit5.2 <- CSC(Hist(time,status)~invasion+epicel+age+strata(sex),
+             data=Melanoma,
+             surv.type="surv",cause=2)
> ## now this does not work
> try(predictRisk(fit5.2,cause=1,newdata=Melanoma,times=4))
Error in predict.CauseSpecificCox(object = object, newdata = newdata,  : 
  Object can be used to predict cause 2 but not 1.
Note: the cause can be specified in CSC(...,cause=).
> 
> ## but this does
> predictRisk(fit5.2,cause=2,newdata=Melanoma,times=100)
               [,1]
  [1,] 6.024245e-02
  [2,] 1.673423e-02
  [3,] 1.835066e-03
  [4,] 2.895922e-02
  [5,] 4.164144e-03
  [6,] 3.517575e-04
  [7,] 4.226097e-02
  [8,] 2.463623e-03
  [9,] 4.611868e-03
 [10,] 2.191509e-02
 [11,] 2.406810e-03
 [12,] 1.511304e-02
 [13,] 2.191509e-02
 [14,] 1.154850e-02
 [15,] 6.425035e-05
 [16,] 2.659387e-02
 [17,] 2.917383e-03
 [18,] 2.068914e-02
 [19,] 1.724844e-01
 [20,] 3.914382e-03
 [21,] 6.822831e-02
 [22,] 1.200253e-03
 [23,] 1.266319e-03
 [24,] 2.208993e-03
 [25,] 2.239422e-02
 [26,] 2.541578e-02
 [27,] 6.570964e-02
 [28,] 3.180427e-03
 [29,] 7.736975e-05
 [30,] 1.102360e-03
 [31,] 2.110609e-02
 [32,] 5.087808e-03
 [33,] 2.014573e-02
 [34,] 2.956986e-03
 [35,] 1.835710e-02
 [36,] 1.858209e-02
 [37,] 2.383689e-04
 [38,] 1.860938e-02
 [39,] 3.180427e-03
 [40,] 8.437599e-03
 [41,] 3.829844e-03
 [42,] 1.693350e-02
 [43,] 4.705314e-03
 [44,] 4.487192e-02
 [45,] 6.388287e-04
 [46,] 1.034547e-01
 [47,] 2.135234e-02
 [48,] 1.154850e-02
 [49,] 1.354302e-02
 [50,] 6.435496e-02
 [51,] 1.980824e-01
 [52,] 2.595079e-02
 [53,] 2.110609e-02
 [54,] 5.060864e-03
 [55,] 5.634319e-04
 [56,] 3.490063e-03
 [57,] 3.291931e-03
 [58,] 1.644268e-03
 [59,] 4.960533e-04
 [60,] 1.256050e-03
 [61,] 9.505245e-04
 [62,] 1.234149e-02
 [63,] 1.836095e-02
 [64,] 7.887092e-03
 [65,] 6.549697e-03
 [66,] 3.829844e-03
 [67,] 7.543867e-04
 [68,] 2.541578e-02
 [69,] 6.687805e-04
 [70,] 5.348562e-03
 [71,] 7.730730e-04
 [72,] 1.152500e-01
 [73,] 2.898261e-03
 [74,] 3.722244e-04
 [75,] 8.654954e-03
 [76,] 1.754134e-03
 [77,] 5.968612e-03
 [78,] 8.591512e-03
 [79,] 3.149017e-03
 [80,] 1.783821e-03
 [81,] 3.180427e-03
 [82,] 1.924911e-03
 [83,] 2.423611e-03
 [84,] 1.486153e-02
 [85,] 2.068766e-03
 [86,] 1.616160e-02
 [87,] 9.339511e-03
 [88,] 1.390024e-02
 [89,] 3.789563e-02
 [90,] 3.750888e-03
 [91,] 8.335454e-03
 [92,] 6.823073e-03
 [93,] 1.152500e-01
 [94,] 2.425237e-02
 [95,] 1.070093e-03
 [96,] 1.434706e-02
 [97,] 1.300086e-03
 [98,] 8.053401e-04
 [99,] 4.119387e-04
[100,] 6.823073e-03
[101,] 1.042223e-02
[102,] 1.264383e-01
[103,] 1.819900e-02
[104,] 9.426792e-03
[105,] 1.858209e-02
[106,] 4.960533e-04
[107,] 1.154605e-02
[108,] 1.101470e-02
[109,] 1.885227e-03
[110,] 2.869300e-02
[111,] 3.789563e-02
[112,] 2.193280e-03
[113,] 1.525157e-02
[114,] 2.316091e-02
[115,] 2.383616e-03
[116,] 5.495746e-03
[117,] 3.177860e-02
[118,] 8.654954e-03
[119,] 3.361226e-03
[120,] 8.483369e-04
[121,] 3.291931e-03
[122,] 1.284933e-02
[123,] 1.147444e-02
[124,] 5.748279e-03
[125,] 5.149310e-02
[126,] 9.505245e-04
[127,] 5.988205e-03
[128,] 7.755833e-03
[129,] 3.095398e-02
[130,] 1.821370e-03
[131,] 3.791371e-03
[132,] 5.666101e-03
[133,] 1.064161e-02
[134,] 2.155038e-02
[135,] 4.773557e-03
[136,] 3.964116e-03
[137,] 1.957488e-03
[138,] 5.968612e-03
[139,] 3.242623e-02
[140,] 2.586680e-03
[141,] 2.041436e-02
[142,] 3.418111e-03
[143,] 9.587239e-04
[144,] 2.357191e-03
[145,] 8.965628e-04
[146,] 8.661945e-04
[147,] 4.678921e-04
[148,] 1.101470e-02
[149,] 7.251235e-02
[150,] 3.726896e-02
[151,] 7.831306e-02
[152,] 1.021560e-03
[153,] 1.143690e-02
[154,] 2.641130e-03
[155,] 7.445348e-04
[156,] 3.514603e-02
[157,] 2.618734e-03
[158,] 3.726896e-02
[159,] 7.730730e-04
[160,] 8.740575e-03
[161,] 4.034461e-04
[162,] 1.114791e-02
[163,] 1.511304e-02
[164,] 1.426658e-03
[165,] 3.829844e-03
[166,] 1.230155e-03
[167,] 7.830219e-03
[168,] 5.060864e-03
[169,] 2.095445e-03
[170,] 3.396506e-02
[171,] 5.869281e-03
[172,] 2.733726e-03
[173,] 1.234149e-02
[174,] 2.537447e-05
[175,] 2.425237e-02
[176,] 1.223256e-02
[177,] 3.226668e-04
[178,] 7.595938e-03
[179,] 5.850284e-04
[180,] 2.135234e-02
[181,] 1.042223e-02
[182,] 8.053401e-04
[183,] 8.661945e-04
[184,] 1.184743e-03
[185,] 9.146967e-03
[186,] 7.972720e-05
[187,] 1.231149e-04
[188,] 6.616609e-03
[189,] 3.750888e-03
[190,] 2.898364e-04
[191,] 2.013372e-03
[192,] 3.964116e-03
[193,] 1.354302e-02
[194,] 1.789676e-03
[195,] 1.472864e-02
[196,] 6.419849e-04
[197,] 9.083777e-04
[198,] 8.591512e-03
[199,] 4.427243e-04
[200,] 2.310460e-04
[201,] 4.927806e-04
[202,] 5.869489e-04
[203,] 2.491192e-03
[204,] 4.116062e-03
[205,] 7.893463e-04
> predict(fit5.2,cause=2,newdata=Melanoma,times=100)
     observation invasion      epicel age times     strata  absRisk
  1:           1  level.1     present  76   100   sex=Male 0.060242
  2:           2  level.0 not present  56   100   sex=Male 0.016734
  3:           3  level.1 not present  41   100   sex=Male 0.001835
  4:           4  level.0 not present  71   100 sex=Female 0.028959
  5:           5  level.2     present  52   100   sex=Male 0.004164
 ---                                                               
201:         201  level.2     present  29   100   sex=Male 0.000493
202:         202  level.2     present  40   100 sex=Female 0.000587
203:         203  level.0     present  42   100 sex=Female 0.002491
204:         204  level.0 not present  50   100 sex=Female 0.004116
205:         205  level.1 not present  41   100 sex=Female 0.000789
> predict(fit5.2,cause=2,newdata=Melanoma[4,],times=100)
   observation invasion      epicel age times     strata absRisk
1:           1  level.0 not present  71   100 sex=Female   0.029
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("Ctree")
> ### * Ctree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Ctree
> ### Title: S3-Wrapper for ctree.
> ### Aliases: Ctree
> 
> ### ** Examples
> 
> if (requireNamespace("party",quietly=TRUE)){
+ library(prodlim)
+ library(party)
+ library(survival)
+ set.seed(50)
+ d <- SimSurv(50)
+ nd <- data.frame(X1=c(0,1,0),X2=c(-1,0,1))
+ f <- Ctree(Surv(time,status)~X1+X2,data=d)
+ predictRisk(f,newdata=nd,times=c(3,8))
+ }
Loading required package: grid
Loading required package: mvtnorm
Loading required package: modeltools
Loading required package: stats4
Loading required package: strucchange
Loading required package: zoo

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric

Loading required package: sandwich
           [,1]      [,2]
[1,] 0.09090909 0.2975207
[2,] 0.00000000 0.7460317
[3,] 0.33333333 0.7777778
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:party’, ‘package:strucchange’,
  ‘package:sandwich’, ‘package:zoo’, ‘package:modeltools’,
  ‘package:stats4’, ‘package:mvtnorm’, ‘package:grid’,
  ‘package:prodlim’

> nameEx("FGR")
> ### * FGR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FGR
> ### Title: Formula wrapper for crr from cmprsk
> ### Aliases: FGR
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(survival)
> library(cmprsk)
> library(lava)
> d <- prodlim::SimCompRisk(100)
> f1 <- FGR(Hist(time,cause)~X1+X2,data=d)
Argument cause missing. Analyse cause: 1
> print(f1)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ X1 + X2, data = d, cause = "1")

    coef exp(coef) se(coef)    z p-value
X1 1.200      3.32    0.343 3.50 0.00046
X2 0.869      2.39    0.244 3.56 0.00036

   exp(coef) exp(-coef) 2.5% 97.5%
X1      3.32      0.301 1.70  6.50
X2      2.39      0.419 1.48  3.85

Num. cases = 100
Pseudo Log-likelihood = -172 
Pseudo likelihood ratio test = 36.9  on 2 df,

Convergence: TRUE 

> 
> ## crr allows that some covariates are multiplied by
> ## a function of time (see argument tf of crr)
> ## by FGR uses the identity matrix
> f2 <- FGR(Hist(time,cause)~cov2(X1)+X2,data=d)
Argument cause missing. Analyse cause: 1
> print(f2)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1) + X2, data = d, cause = "1")

        coef exp(coef) se(coef)    z p-value
X2     0.854      2.35   0.2254 3.79 0.00015
X1*tf1 0.176      1.19   0.0865 2.04 0.04200

       exp(coef) exp(-coef) 2.5% 97.5%
X2          2.35      0.426 1.51  3.66
X1*tf1      1.19      0.839 1.01  1.41

Num. cases = 100
Pseudo Log-likelihood = -177 
Pseudo likelihood ratio test = 27.5  on 2 df,

Convergence: TRUE 

> 
> ## same thing, but more explicit:
> f3 <- FGR(Hist(time,cause)~cov2(X1)+cov1(X2),data=d)
Argument cause missing. Analyse cause: 1
> print(f3)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1) + cov1(X2), data = d, 
    cause = "1")

        coef exp(coef) se(coef)    z p-value
X2     0.854      2.35   0.2254 3.79 0.00015
X1*tf1 0.176      1.19   0.0865 2.04 0.04200

       exp(coef) exp(-coef) 2.5% 97.5%
X2          2.35      0.426 1.51  3.66
X1*tf1      1.19      0.839 1.01  1.41

Num. cases = 100
Pseudo Log-likelihood = -177 
Pseudo likelihood ratio test = 27.5  on 2 df,

Convergence: TRUE 

> 
> ## both variables can enter cov2:
> f4 <- FGR(Hist(time,cause)~cov2(X1)+cov2(X2),data=d)
Argument cause missing. Analyse cause: 1
> print(f4)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1) + cov2(X2), data = d, 
    cause = "1")

        coef exp(coef) se(coef)    z p-value
X1*tf1 0.168      1.18   0.0800 2.10   0.036
X2*tf2 0.115      1.12   0.0509 2.25   0.024

       exp(coef) exp(-coef) 2.5% 97.5%
X1*tf1      1.18      0.845 1.01  1.38
X2*tf2      1.12      0.892 1.02  1.24

Num. cases = 100
Pseudo Log-likelihood = -183 
Pseudo likelihood ratio test = 14.4  on 2 df,

Convergence: TRUE 

> 
> ## change the function of time
> qFun <- function(x){x^2}
> noFun <- function(x){x}
> sqFun <- function(x){x^0.5}
> 
> ## multiply X1 by time^2 and X2 by time:
> f5 <- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2),data=d)
Argument cause missing. Analyse cause: 1
> print(f5)

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ cov2(X1, tf = qFun) + cov2(X2), 
    data = d, cause = "1")

         coef exp(coef) se(coef)     z p-value
X1*tf1 0.0112      1.01   0.0121 0.926   0.350
X2*tf2 0.1183      1.13   0.0476 2.486   0.013

       exp(coef) exp(-coef)  2.5% 97.5%
X1*tf1      1.01      0.989 0.988  1.04
X2*tf2      1.13      0.888 1.025  1.24

Num. cases = 100
Pseudo Log-likelihood = -186 
Pseudo likelihood ratio test = 9.7  on 2 df,

Convergence: TRUE 

> print(f5$crrFit)
convergence:  TRUE 
coefficients:
X1*tf1 X2*tf2 
0.0112 0.1183 
standard errors:
[1] 0.01209 0.04760
two-sided p-values:
X1*tf1 X2*tf2 
 0.350  0.013 
> ## same results as crr
> with(d,crr(ftime=time,
+            fstatus=cause,
+            cov2=d[,c("X1","X2")],
+            tf=function(time){cbind(qFun(time),time)}))
convergence:  TRUE 
coefficients:
 X1*tf1 X2*time 
 0.0112  0.1183 
standard errors:
[1] 0.01209 0.04760
two-sided p-values:
 X1*tf1 X2*time 
  0.350   0.013 
> 
> ## still same result, but more explicit
> f5a <- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2,tf=noFun),data=d)
Argument cause missing. Analyse cause: 1
> f5a$crrFit
convergence:  TRUE 
coefficients:
X1*tf1 X2*tf2 
0.0112 0.1183 
standard errors:
[1] 0.01209 0.04760
two-sided p-values:
X1*tf1 X2*tf2 
 0.350  0.013 
> 
> ## multiply X1 by time^2 and X2 by sqrt(time)
> f5b <- FGR(Hist(time,cause)~cov2(X1,tf=qFun)+cov2(X2,tf=sqFun),data=d,cause=1)
> 
> ## additional arguments for crr
> f6<- FGR(Hist(time,cause)~X1+X2,data=d, cause=1,gtol=1e-5)
> f6

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ X1 + X2, data = d, cause = 1, 
    gtol = 1e-05)

    coef exp(coef) se(coef)    z p-value
X1 1.200      3.32    0.343 3.50 0.00046
X2 0.869      2.39    0.244 3.56 0.00036

   exp(coef) exp(-coef) 2.5% 97.5%
X1      3.32      0.301 1.70  6.50
X2      2.39      0.419 1.48  3.85

Num. cases = 100
Pseudo Log-likelihood = -172 
Pseudo likelihood ratio test = 36.9  on 2 df,

Convergence: TRUE 

> f6a<- FGR(Hist(time,cause)~X1+X2,data=d, cause=1,gtol=0.1)
> f6a

Right-censored response of a competing.risks model

No.Observations: 100 

Pattern:
         
Cause     event right.censored
  1          47              0
  2          26              0
  unknown     0             27


Fine-Gray model: analysis of cause 1 

Competing Risks Regression

Call:
FGR(formula = Hist(time, cause) ~ X1 + X2, data = d, cause = 1, 
    gtol = 0.1)

    coef exp(coef) se(coef)    z p-value
X1 1.425      4.16    0.355 4.01 0.00006
X2 0.869      2.39    0.258 3.37 0.00076

   exp(coef) exp(-coef) 2.5% 97.5%
X1      4.16      0.240 2.07  8.34
X2      2.39      0.419 1.44  3.96

Num. cases = 100
Pseudo Log-likelihood = -172 
Pseudo likelihood ratio test = 36.3  on 2 df,

Convergence: TRUE 

> 
> 
> 
> cleanEx()

detaching ‘package:lava’, ‘package:cmprsk’, ‘package:survival’,
  ‘package:prodlim’

> nameEx("IPA")
> ### * IPA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: IPA
> ### Title: Explained variation for settings with binary, survival and
> ###   competing risk outcome
> ### Aliases: IPA rsquared rsquared.default rsquared.glm rsquared.coxph
> ###   rsquared.CauseSpecificCox IPA.default IPA.glm IPA.coxph
> ###   IPA.CauseSpecificCox
> 
> ### ** Examples
> 
> library(prodlim)
> library(data.table)
> # binary outcome
> library(lava)
> set.seed(18)
> learndat <- sampleData(48,outcome="binary")
> lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family=binomial)
> IPA(lr1)
     Variable Brier  IPA IPA.drop
1: Null model  24.8  0.0     37.1
2: Full model  15.6 37.1      0.0
3:         X1  19.5 21.6     15.5
4:         X2  15.8 36.3      0.8
5:         X7  16.0 35.4      1.7
6:         X9  21.2 14.6     22.5

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
> 
> ## validation data
> valdat=sampleData(94,outcome="binary")
> IPA(lr1,newdata=valdat)
     Variable Brier  IPA IPA.drop
1: Null model  23.6  0.0     -1.3
2: Full model  23.9 -1.3      0.0
3:         X1  23.9 -0.9     -0.3
4:         X2  23.2  1.9     -3.1
5:         X7  24.0 -1.7      0.4
6:         X9  23.5  0.5     -1.8

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
> 
> ## predicted risks externally given
> p1=predictRisk(lr1,newdata=valdat)
> IPA(p1,formula=Y~1,valdat)
        model Brier  IPA
1: Null model  23.6  0.0
2:    numeric  23.9 -1.3

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
> 
> # survival
> library(survival)
> data(pbc)
> pbc=na.omit(pbc)
> pbctest=(1:NROW(pbc)) %in% sample(1:NROW(pbc),size=.632*NROW(pbc))
> pbclearn=pbc[pbctest,]
> cox1= coxph(Surv(time,status!=0)~age+sex+log(bili)+log(albumin)+log(protime),
+       data=pbclearn,x=TRUE)
> 
> ## same data
> IPA(cox1,formula=Surv(time,status!=0)~1,times=1000)
       Variable times Brier  IPA IPA.drop
1:   Null model  1000  13.5  0.0     31.8
2:   Full model  1000   9.2 31.8      0.0
3:          age  1000   9.2 31.9     -0.2
4:          sex  1000   9.2 31.9     -0.2
5:    log(bili)  1000  11.7 13.6     18.2
6: log(albumin)  1000   9.8 27.5      4.2
7: log(protime)  1000   9.4 30.9      0.9

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
> 
> ## validation data
> pbcval=pbc[!pbctest,]
> IPA(cox1,formula=Surv(time,status!=0)~1,newdata=pbcval,times=1000)
       Variable times Brier  IPA IPA.drop
1:   Null model  1000  18.5  0.0     25.1
2:   Full model  1000  13.9 25.1      0.0
3:          age  1000  14.0 24.4      0.6
4:          sex  1000  13.9 24.8      0.3
5:    log(bili)  1000  15.2 18.0      7.1
6: log(albumin)  1000  13.7 25.9     -0.8
7: log(protime)  1000  14.2 23.4      1.7

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
> 
> ## predicted risks externally given
> p2=predictRisk(cox1,newdata=pbcval,times=1000)
> IPA(cox1,formula=Surv(time,status!=0)~1,newdata=pbcval,times=1000)
       Variable times Brier  IPA IPA.drop
1:   Null model  1000  18.5  0.0     25.1
2:   Full model  1000  13.9 25.1      0.0
3:          age  1000  14.0 24.4      0.6
4:          sex  1000  13.9 24.8      0.3
5:    log(bili)  1000  15.2 18.0      7.1
6: log(albumin)  1000  13.7 25.9     -0.8
7: log(protime)  1000  14.2 23.4      1.7

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
>  
> # competing risks
> data(Melanoma)
> Melanomatest=(1:NROW(Melanoma)) %in% sample(1:NROW(Melanoma),size=.632*NROW(Melanoma))
> Melanomalearn=Melanoma[Melanomatest,]
> fit1 <- CSC(list(Hist(time,status)~sex,
+                  Hist(time,status)~invasion+epicel+age),
+                  data=Melanoma)
> IPA(fit1,times=1000,cause=2)
     Variable times Brier  IPA IPA.drop
1: Null model  1000   3.3  0.0      2.9
2: Full model  1000   3.2  2.9      0.0
3:        sex  1000   3.2  2.8      0.1
4:   invasion  1000   3.2  4.0     -1.2
5:     epicel  1000   3.2  3.1     -0.2
6:        age  1000   3.3 -0.8      3.6

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
> 
> ## validation data
> Melanomaval=Melanoma[!Melanomatest,]
> IPA(fit1,formula=Hist(time,status)~1,newdata=Melanomaval,times=1000)
     Variable times Brier  IPA IPA.drop
1: Null model  1000  11.6  0.0      4.6
2: Full model  1000  11.0  4.6      0.0
3:        sex  1000  11.6 -0.0      4.6
4:   invasion  1000  11.0  4.4      0.2
5:     epicel  1000  11.0  4.5      0.1
6:        age  1000  11.0  4.6     -0.0

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
> 
> ## predicted risks externally given
> p3= predictRisk(fit1,cause=1,newdata=Melanomaval,times=1000)
> IPA(p3,formula=Hist(time,status)~1,cause=1,newdata=Melanomaval,times=1000)
        model times Brier IPA
1: Null model  1000  11.6 0.0
2:     matrix  1000  11.0 4.6

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher IPA the better.
NOTE: IPA.drop = IPA(Full model) - IPA. The higher the drop
the more important is the variable for the full model.
>  
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:lava’, ‘package:data.table’,
  ‘package:prodlim’

> nameEx("Melanoma")
> ### * Melanoma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Melanoma
> ### Title: Malignant melanoma data
> ### Aliases: Melanoma
> ### Keywords: datasets
> 
> ### ** Examples
> 
> 
> data(Melanoma)
> 
> 
> 
> cleanEx()
> nameEx("Paquid")
> ### * Paquid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Paquid
> ### Title: Paquid sample
> ### Aliases: Paquid
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(Paquid)
> 
> 
> 
> cleanEx()
> nameEx("Score.list")
> ### * Score.list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Score.list
> ### Title: Score risk predictions
> ### Aliases: Score.list Score
> 
> ### ** Examples
> 
> # binary outcome
> library(lava)
> set.seed(18)
> learndat <- sampleData(48,outcome="binary")
> testdat <- sampleData(40,outcome="binary")
> 
> ## score logistic regression models
> lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family=binomial)
> lr2 = glm(Y~X3+X5,data=learndat,family=binomial)
> Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5)"=lr2),formula=Y~1,data=testdat)

Metric AUC:

Results by model:

             model  AUC lower upper
1: LR(X1+X2+X7+X9) 60.7  42.3  79.1
2:       LR(X3+X5) 44.2  26.9  61.6

Results of model comparisons:

       model       reference delta.AUC lower upper   p
1: LR(X3+X5) LR(X1+X2+X7+X9)     -16.4 -38.2   5.3 0.1

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher AUC the better.

Metric Brier:

Results by model:

             model Brier lower upper
1:      Null model  24.9  24.2  25.7
2: LR(X1+X2+X7+X9)  27.9  19.0  36.8
3:       LR(X3+X5)  25.4  24.0  26.9

Results of model comparisons:

             model       reference delta.Brier lower upper         p
1: LR(X1+X2+X7+X9)      Null model         3.0  -5.9  11.8 0.5124805
2:       LR(X3+X5)      Null model         0.5  -0.4   1.4 0.2747143
3:       LR(X3+X5) LR(X1+X2+X7+X9)        -2.5 -11.1   6.2 0.5778617

NOTE: Values are multiplied by 100 and given in %.
NOTE: The lower Brier the better.
> 
> ## ROC curve and calibration plot
> xb=Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5+X6)"=lr2),formula=Y~1,
+          data=testdat,plots=c("calibration","ROC"))
> ## Not run: 
> ##D plotROC(xb)
> ##D plotCalibration(xb)
> ## End(Not run)
> 
> ## compute AUC for a list of continuous markers
> markers = as.list(testdat[,.(X6,X7,X8,X9,X10)])
> Score(markers,formula=Y~1,data=testdat,metrics=c("auc"))

Metric AUC:

Results by model:

   model  AUC lower upper
1:    X6 86.7  75.3  98.2
2:    X7 38.6  20.7  56.5
3:    X8 46.4  27.7  65.0
4:    X9 35.3  17.9  52.8
5:   X10 46.4  27.8  65.0

Results of model comparisons:

    model reference delta.AUC lower upper     p
 1:    X7        X6     -48.1 -69.7 -26.6 1e-05
 2:    X8        X6     -40.4 -63.6 -17.1 7e-04
 3:    X9        X6     -51.4 -73.3 -29.4 4e-06
 4:   X10        X6     -40.4 -61.8 -18.9 2e-04
 5:    X8        X7       7.8 -17.0  32.6 5e-01
 6:    X9        X7      -3.3 -26.6  20.1 8e-01
 7:   X10        X7       7.8 -17.4  32.9 5e-01
 8:    X9        X8     -11.0 -34.8  12.7 4e-01
 9:   X10        X8       0.0 -27.4  27.4 1e+00
10:   X10        X9      11.0 -12.1  34.2 4e-01

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher AUC the better.
> 
> # cross-validation
> ## Not run: 
> ##D     learndat=sampleData(400,outcome="binary")
> ##D     lr1a = glm(Y~X6,data=learndat,family=binomial)
> ##D     lr2a = glm(Y~X7+X8+X9,data=learndat,family=binomial)
> ##D     ## bootstrap cross-validation
> ##D     x1=Score(list("LR1"=lr1a,"LR2"=lr2a),formula=Y~1,data=learndat,split.method="bootcv",B=100)
> ##D     x1
> ##D     ## leave-one-out and leave-pair-out bootstrap
> ##D     x2=Score(list("LR1"=lr1a,"LR2"=lr2a),formula=Y~1,data=learndat,
> ##D              split.method="loob",
> ##D              B=100,plots="calibration")
> ##D     x2
> ## End(Not run)
> # survival outcome
> 
> # Score Cox regression models
> ## Not run: 
> ##D library(survival)
> ##D library(rms)
> ##D library(prodlim)
> ##D set.seed(18)
> ##D trainSurv <- sampleData(100,outcome="survival")
> ##D testSurv <- sampleData(40,outcome="survival")
> ##D cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
> ##D cox2 = coxph(Surv(time,event)~X3+X5+X6,data=trainSurv, y=TRUE, x = TRUE)
> ##D xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D          formula=Surv(time,event)~1,data=testSurv,conf.int=FALSE,times=c(5,8))
> ##D xs
> ## End(Not run)
> 
> # Integrated Brier score
> ## Not run: 
> ##D xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D          formula=Surv(time,event)~1,data=testSurv,conf.int=FALSE,
> ##D          summary="ibs",
> ##D          times=sort(unique(testSurv$time)))
> ## End(Not run)
> 
> # time-dependent AUC for list of markers
> ## Not run: 
> ##D survmarkers = as.list(testSurv[,.(X6,X7,X8,X9,X10)])
> ##D Score(survmarkers,
> ##D       formula=Surv(time,event)~1,metrics="auc",data=testSurv,
> ##D       conf.int=TRUE,times=c(5,8))
> ##D 
> ##D # compare models on test data
> ##D Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D       formula=Surv(time,event)~1,data=testSurv,conf.int=TRUE,times=c(5,8))
> ## End(Not run)
> # crossvalidation models in traindata
> ## Not run: 
> ##D     library(survival)
> ##D     set.seed(18)
> ##D     trainSurv <- sampleData(400,outcome="survival")
> ##D     cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv, y=TRUE, x = TRUE)
> ##D     cox2 = coxph(Surv(time,event)~X3+X5+X6,data=trainSurv, y=TRUE, x = TRUE)
> ##D     x1 = Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D                formula=Surv(time,event)~1,data=trainSurv,conf.int=TRUE,times=c(5,8),
> ##D                split.method="loob",B=100,plots="calibration")
> ##D 
> ##D     x2= Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D               formula=Surv(time,event)~1,data=trainSurv,conf.int=TRUE,times=c(5,8),
> ##D               split.method="bootcv",B=100)
> ## End(Not run)
> 
> # restrict number of comparisons
> ## Not run: 
> ##D     Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),
> ##D           formula=Surv(time,event)~1,data=trainSurv,contrasts=TRUE,
> ##D           null.model=FALSE,conf.int=TRUE,times=c(5,8),split.method="bootcv",B=3)
> ##D 
> ##D     # competing risks outcome
> ##D     set.seed(18)
> ##D     trainCR <- sampleData(40,outcome="competing.risks")
> ##D     testCR <- sampleData(40,outcome="competing.risks")
> ##D     library(riskRegression)
> ##D     library(cmprsk)
> ##D     # Cause-specific Cox regression
> ##D     csc1 = CSC(Hist(time,event)~X1+X2+X7+X9,data=trainCR)
> ##D     csc2 = CSC(Hist(time,event)~X3+X5+X6,data=trainCR)
> ##D     # Fine-Gray regression
> ##D     fgr1 = FGR(Hist(time,event)~X1+X2+X7+X9,data=trainCR,cause=1)
> ##D     fgr2 = FGR(Hist(time,event)~X3+X5+X6,data=trainCR,cause=1)
> ##D     Score(list("CSC(X1+X2+X7+X9)"=csc1,"CSC(X3+X5+X6)"=csc2,
> ##D                "FGR(X1+X2+X7+X9)"=fgr1,"FGR(X3+X5+X6)"=fgr2),
> ##D           formula=Hist(time,event)~1,data=testCR,se.fit=1L,times=c(5,8))
> ## End(Not run)
> 
> 
> 
> ## Not run: 
> ##D     # reproduce some results of Table IV of Blanche et al. Stat Med 2013
> ##D     data(Paquid)
> ##D     ResPaquid <- Score(list("DSST"=-Paquid$DSST,"MMSE"=-Paquid$MMSE),
> ##D                        formula=Hist(time,status)~1,
> ##D                        data=Paquid,
> ##D                        null.model = FALSE,
> ##D                        conf.int=TRUE,
> ##D                        metrics=c("auc"),
> ##D                        times=c(3,5,10),
> ##D                        plots="ROC")
> ##D     ResPaquid
> ##D     plotROC(ResPaquid,time=5)
> ## End(Not run)
> ## Not run: 
> ##D # parallel options
> ##D # by erikvona: Here is a generic example of using future
> ##D # and doFuture, works great with the current version:
> ##D library(riskRegression)
> ##D library(future)
> ##D library(foreach)
> ##D library(doFuture)
> ##D library(survival)
> ##D # Register all available cores for parallel operation
> ##D plan(multiprocess, workers = availableCores())
> ##D registerDoFuture()
> ##D trainSurv <- sampleData(400,outcome="survival")
> ##D cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=trainSurv,
> ##D              y=TRUE, x = TRUE)
> ##D # Bootstrapping on multiple cores
> ##D x1 = Score(list("Cox(X1+X2+X7+X9)"=cox1),
> ##D      formula=Surv(time,event)~1,data=trainSurv, times=c(5,8), 
> ##D      parallel = "as.registered", split.method="bootcv",B=100)
> ## End(Not run)
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:lava’

> nameEx("SuperPredictor")
> ### * SuperPredictor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SuperPredictor
> ### Title: Formula interface for SuperLearner::SuperLearner
> ### Aliases: SuperPredictor
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if(requireNamespace("SuperLearner",quietly=TRUE)){
> ##D library(SuperLearner)
> ##D library(data.table)
> ##D d = sampleData(338, outcome="binary")
> ##D spfit = SuperPredictor(Y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=d)
> ##D predictRisk(spfit)
> ##D x <- Score(list(spfit),data=d,formula=Y~1)
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("SurvResponseVar")
> ### * SurvResponseVar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SurvResponseVar
> ### Title: Extract the time and event variable from a Cox model
> ### Aliases: SurvResponseVar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D SurvResponseVar(Surv(time,event)~X1+X2)
> ##D SurvResponseVar(Hist(time,event==0)~X1+X2)
> ##D SurvResponseVar(Surv(start,time, status,type="counting") ~ X3+X5)
> ##D SurvResponseVar(Surv(start,event=status, time2=time,type="counting") ~ X3+X5)
> ##D 
> ##D SurvResponseVar(survival::Surv(start,event=status, time2=time,type="counting") ~ X3+X5)
> ##D SurvResponseVar(status ~ X3+X5)
> ##D SurvResponseVar(I(status == 1) ~ X3+X5)
> ##D SurvResponseVar(list(Hist(time, event) ~ X1+X6,Hist(time, event) ~ X6))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("anova.ate")
> ### * anova.ate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anova.ate
> ### Title: Risk Comparison Over Time
> ### Aliases: anova.ate
> 
> ### ** Examples
> 
> library(survival)
> library(data.table)
> 
> ## Not run: 
> ##D ## simulate data
> ##D set.seed(12)
> ##D n <- 200
> ##D dtS <- sampleData(n,outcome="survival")
> ##D dtS$X12 <- LETTERS[as.numeric(as.factor(paste0(dtS$X1,dtS$X2)))]
> ##D dtS <- dtS[dtS$X12!="D"]
> ##D 
> ##D ## model fit
> ##D fit <- cph(formula = Surv(time,event)~ X1+X6,data=dtS,y=TRUE,x=TRUE)
> ##D seqTime <- 1:10
> ##D ateFit <- ate(fit, data = dtS, treatment = "X1", contrasts = NULL,
> ##D               times = seqTime, B = 0, iid = TRUE, se = TRUE, verbose = TRUE, band = TRUE)
> ##D 
> ##D ## display
> ##D autoplot(ateFit)
> ##D 
> ##D ## inference (two sided)
> ##D statistic <- ateFit$diffRisk$estimate/ateFit$diffRisk$se
> ##D confint(ateFit, p.value = TRUE, method.band = "bonferroni")$diffRisk
> ##D confint(ateFit, p.value = TRUE, method.band = "maxT-simulation")$diffRisk
> ##D 
> ##D anova(ateFit, test = "KS")
> ##D anova(ateFit, test = "CvM")
> ##D anova(ateFit, test = "sum")
> ##D 
> ##D ## manual calculation (one sided)
> ##D n.sim <- 1e4
> ##D statistic <- ateFit$diffRisk[, estimate/se]
> ##D iid.norm <- scale(ateFit$iid$GFORMULA[["1"]]-ateFit$iid$GFORMULA[["0"]],
> ##D                   scale = ateFit$diffRisk$se)
> ##D 
> ##D ls.out <- lapply(1:n.sim, function(iSim){
> ##D iG <- rnorm(NROW(iid.norm))
> ##D iCurve <- t(iid.norm) %*% iG
> ##D data.table(max = max(iCurve), L2 = sum(iCurve^2), sum = sum(iCurve),
> ##D maxC = max(iCurve) - max(statistic),
> ##D L2C = sum(iCurve^2) - sum(statistic^2),
> ##D sumC = sum(iCurve) - sum(statistic),
> ##D sim = iSim)
> ##D })
> ##D 
> ##D dt.out <- do.call(rbind,ls.out)
> ##D dt.out[,.(max = mean(.SD$maxC>=0),
> ##D           L2 = mean(.SD$L2C>=0),
> ##D           sum = mean(.SD$sumC>=0))]
> ##D 
> ##D ## permutation
> ##D n.sim <- 250
> ##D stats.perm <- vector(mode = "list", length = n.sim)
> ##D pb <- txtProgressBar(max = n.sim, style=3)
> ##D treatVar <- ateFit$variables["treatment"]
> ##D 
> ##D for(iSim in 1:n.sim){ ## iSim <- 1
> ##D iData <- copy(dtS)
> ##D iIndex <- sample.int(NROW(iData), replace = FALSE)
> ##D iData[, c(treatVar) := .SD[[treatVar]][iIndex]]
> ##D 
> ##D iFit <- update(fit, data = iData)
> ##D iAteSim <- ate(iFit, data = iData, treatment = treatVar,
> ##D                times = seqTime, verbose = FALSE)
> ##D iStatistic <- iAteSim$diffRisk[,estimate/se]
> ##D stats.perm[[iSim]] <- cbind(iAteSim$diffRisk[,.(max = max(iStatistic),
> ##D                                                 L2 = sum(iStatistic^2),
> ##D                                                 sum = sum(iStatistic))],
> ##D                             sim = iSim)
> ##D stats.perm[[iSim]]$maxC <- stats.perm[[iSim]]$max - max(statistic)
> ##D stats.perm[[iSim]]$L2C <- stats.perm[[iSim]]$L2 - sum(statistic^2)
> ##D stats.perm[[iSim]]$sumC <- stats.perm[[iSim]]$sum - sum(statistic)
> ##D setTxtProgressBar(pb, iSim)
> ##D }
> ##D 
> ##D dtstats.perm <- do.call(rbind,stats.perm)
> ##D dtstats.perm[,.(max = mean(.SD$maxC>=0),
> ##D                 L2 = mean(.SD$L2C>=0),
> ##D                 sum = mean(.SD$sumC>=0))]
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:survival’

> nameEx("ate")
> ### * ate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ate
> ### Title: Average Treatment Effects Computation
> ### Aliases: ate
> 
> ### ** Examples
> 
> library(survival)
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> library(prodlim)
> library(data.table)
> set.seed(10)
> 
> #### Survival settings  ####
> #### ATE with Cox model ####
> 
> ## generate data
> n <- 100
> dtS <- sampleData(n, outcome="survival")
> dtS$time <- round(dtS$time,1)
> dtS$X1 <- factor(rbinom(n, prob = c(0.3,0.4) , size = 2), labels = paste0("T",0:2))
> 
> ## estimate the Cox model
> fit <- cph(formula = Surv(time,event)~ X1+X2,data=dtS,y=TRUE,x=TRUE)
> 
> ## compute the ATE at times 5, 6, 7, and 8 using X1 as the treatment variable
> ## standard error computed using the influence function
> ## confidence intervals / p-values based on asymptotic results
> ateFit1a <- ate(fit, data = dtS, treatment = "X1", times = 5:8)
 Input variables 
 - Treatment            : X1 (3 levels: "T0" "T1" "T2")
 - Event                : event (cause: 1, censoring: 0)
 - Time  [min;max]      : time [0.6;15.7]
 - Eval. time           :  5  6  7  8
      number at risk T0   16 13 10  7
      number at risk T1   26 21 18 11
      number at risk T2    7  3  3  1

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Processing
 - Prepare influence function: outcome done 
 - Point estimation: done 
 - Decomposition iid: done
 - Confidence intervals: done
> summary(ateFit1a)
     Average treatment effect 

 - Treatment            : X1 (3 levels: "T0" "T1" "T2")
 - Event                : event (cause: 1, censoring: 0)
 - Time  [min;max]      : time [0.6;15.7]
 - Eval. time           :  5  6  7  8
      number at risk T0   16 13 10  7
      number at risk T1   26 21 18 11
      number at risk T2    7  3  3  1

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Testing procedure
 - Null hypothesis     : given two treatments (A,B) and a specific timepoint, equal risks 
 - Confidence level    : 0.95

 Results: 
 - Difference in standardized risk (B-A) between time zero and 'time' 
                reported on the scale [-1;1] (difference between two probabilities)
 (difference in average risks when treating all subjects with the experimental treatment (B),
                                vs. treating all subjects with the reference treatment (A))

 time X1=A risk(X1=A) X1=B risk(X1=B) difference           ci p.value
    5   T0      0.472   T1      0.389    -0.0825 [-0.25;0.09]   0.341
    6   T0      0.550   T1      0.461    -0.0896 [-0.27;0.09]   0.341
    7   T0      0.609   T1      0.516    -0.0930 [-0.28;0.10]   0.339
    8   T0      0.641   T1      0.547    -0.0941 [-0.29;0.10]   0.338
    5   T0      0.472   T2      0.448    -0.0239 [-0.26;0.21]   0.841
    6   T0      0.550   T2      0.525    -0.0256 [-0.28;0.22]   0.841
    7   T0      0.609   T2      0.583    -0.0263 [-0.28;0.23]   0.841
    8   T0      0.641   T2      0.615    -0.0264 [-0.29;0.23]   0.841
    5   T1      0.389   T2      0.448     0.0586 [-0.17;0.29]   0.612
    6   T1      0.461   T2      0.525     0.0639 [-0.18;0.31]   0.611
    7   T1      0.516   T2      0.583     0.0667 [-0.19;0.32]   0.609
    8   T1      0.547   T2      0.615     0.0677 [-0.19;0.33]   0.608

 difference      : estimated difference in standardized risks 
 ci              : pointwise confidence intervals 
 p.value         : (unadjusted) p-value 
> summary(ateFit1a, short = TRUE, type = "meanRisk")
 - Standardized risk between time zero and 'time'

 time X1  risk          ci
    5 T0 0.472 [0.33;0.62]
    6 T0 0.550 [0.40;0.70]
    7 T0 0.609 [0.46;0.76]
    8 T0 0.641 [0.49;0.79]
    5 T1 0.389 [0.26;0.52]
    6 T1 0.461 [0.33;0.59]
    7 T1 0.516 [0.38;0.66]
    8 T1 0.547 [0.41;0.69]
    5 T2 0.448 [0.25;0.65]
    6 T2 0.525 [0.31;0.74]
    7 T2 0.583 [0.36;0.80]
    8 T2 0.615 [0.39;0.84]

> summary(ateFit1a, short = TRUE, type = "diffRisk")
 - Difference in standardized risk (B-A) between time zero and 'time' 

 time X1=A X1=B difference           ci p.value
    5   T0   T1    -0.0825 [-0.25;0.09]   0.341
    6   T0   T1    -0.0896 [-0.27;0.09]   0.341
    7   T0   T1    -0.0930 [-0.28;0.10]   0.339
    8   T0   T1    -0.0941 [-0.29;0.10]   0.338
    5   T0   T2    -0.0239 [-0.26;0.21]   0.841
    6   T0   T2    -0.0256 [-0.28;0.22]   0.841
    7   T0   T2    -0.0263 [-0.28;0.23]   0.841
    8   T0   T2    -0.0264 [-0.29;0.23]   0.841
    5   T1   T2     0.0586 [-0.17;0.29]   0.612
    6   T1   T2     0.0639 [-0.18;0.31]   0.611
    7   T1   T2     0.0667 [-0.19;0.32]   0.609
    8   T1   T2     0.0677 [-0.19;0.33]   0.608

> summary(ateFit1a, short = TRUE, type = "ratioRisk")
 - Ratio of standardized risks (B/A) between time zero and 'time' 

 time X1=A X1=B ratio          ci p.value
    5   T0   T1 0.825 [0.50;1.15]   0.293
    6   T0   T1 0.837 [0.53;1.14]   0.295
    7   T0   T1 0.847 [0.56;1.14]   0.299
    8   T0   T1 0.853 [0.58;1.13]   0.301
    5   T0   T2 0.949 [0.46;1.43]   0.838
    6   T0   T2 0.953 [0.51;1.40]   0.839
    7   T0   T2 0.957 [0.54;1.37]   0.839
    8   T0   T2 0.959 [0.56;1.36]   0.839
    5   T1   T2 1.150 [0.54;1.76]   0.628
    6   T1   T2 1.139 [0.58;1.69]   0.624
    7   T1   T2 1.129 [0.62;1.64]   0.622
    8   T1   T2 1.124 [0.63;1.61]   0.620

> 
> ## Not run: 
> ##D ## same as before with in addition the confidence bands / adjusted p-values
> ##D ## (argument band = TRUE)
> ##D ateFit1b <- ate(fit, data = dtS, treatment = "X1", times = 5:8,
> ##D                 band = TRUE)
> ##D summary(ateFit1b)
> ##D 
> ##D ## by default bands/adjuste p-values computed separately for each treatment modality
> ##D summary(ateFit1b, band = 1,
> ##D          se = FALSE, type = "diffRisk", short = TRUE, quantile = TRUE)
> ##D ## adjustment over treatment and time using the band argument of confint
> ##D summary(ateFit1b, band = 2,
> ##D        se = FALSE, type = "diffRisk", short = TRUE, quantile = TRUE)
> ##D 
> ##D ## confidence intervals / p-values computed using 1000 boostrap samples
> ##D ## (argument se = TRUE and B = 1000) 
> ##D ateFit1c <- ate(fit, data = dtS, treatment = "X1",
> ##D                 times = 5:8, se = TRUE, B = 50, handler = "mclapply")
> ##D ## NOTE: for real applications 50 bootstrap samples is not enough 
> ##D 
> ##D ## same but using 2 cpus for generating and analyzing the boostrap samples
> ##D ## (parallel computation, argument mc.cores = 2) 
> ##D ateFit1d <- ate(fit, data = dtS, treatment = "X1",
> ##D                 times = 5:8, se = TRUE, B = 50, mc.cores = 2)
> ##D 
> ##D ## manually defining the cluster to be used
> ##D ## useful when specific packages need to be loaded in each cluster
> ##D fit <- cph(formula = Surv(time,event)~ X1+X2+rcs(X6),data=dtS,y=TRUE,x=TRUE)
> ##D 
> ##D cl <- parallel::makeCluster(2)
> ##D parallel::clusterEvalQ(cl, library(rms))
> ##D 
> ##D ateFit1e <- ate(fit, data = dtS, treatment = "X1",
> ##D                 times = 5:8, se = TRUE, B = 50,
> ##D                 handler = "foreach", cl = cl)
> ## End(Not run)
> 
> #### Survival settings without censoring ####
> #### ATE with glm                        ####
> 
> ## generate data
> n <- 100
> dtB <- sampleData(n, outcome="binary")
> dtB[, X2 := as.numeric(X2)]
> 
> ## estimate a logistic regression model
> fit <- glm(formula = Y ~ X1+X2, data=dtB, family = "binomial")
> 
> ## compute the ATE using X1 as the treatment variable
> ## only point estimate (argument se = FALSE)
> ateFit1a <- ate(fit, data = dtB, treatment = "X1", se = FALSE)
 Input variables 
 - Treatment            : X1 (2 levels: "0" "1")
 - Event                : Y (cause: 1, competing risk(s): 0)

 Estimation procedure 
 - Estimator  : G-formula

 Processing
 - Point estimation: done 
> ateFit1a
     Average treatment effect for cause 1 

 - Treatment            : X1 (2 levels: "0" "1")
 - Event                : Y (cause: 1, competing risk(s): 0)

 Estimation procedure 
 - Estimator  : G-formula

 Results 
 - Standardized risks   :                
 X1=A X1=B    risk.A    risk.B difference (B-A) ratio (B/A)
    0    1 0.5853676 0.9444428        0.3590752    1.613418

 - Computation time     : 0.01317596 secs (point estimate)

> 
> ## Not run: 
> ##D ## with confidence intervals
> ##D ateFit1b <- ate(fit, data = dtB, treatment = "X1",
> ##D                times = 5) ## just for having a nice output not used in computations
> ##D summary(ateFit1b, short = TRUE)
> ##D 
> ##D ## using the lava package
> ##D library(lava)
> ##D ateLava <- estimate(fit, function(p, data){
> ##D a <- p["(Intercept)"] ; b <- p["X11"] ; c <- p["X2"] ;
> ##D R.X11 <- expit(a + b + c * data[["X2"]])
> ##D R.X10 <- expit(a + c * data[["X2"]])
> ##D list(risk0=R.X10,risk1=R.X11,riskdiff=R.X11-R.X10)},
> ##D average=TRUE)
> ##D ateLava
> ## End(Not run)
> 
> #### Competing risks settings               ####
> #### ATE with cause specific Cox regression ####
> 
> ## generate data
> n <- 500
> set.seed(10)
> dt <- sampleData(n, outcome="competing.risks")
> dt$X1 <- factor(rbinom(n, prob = c(0.2,0.3) , size = 2), labels = paste0("T",0:2))
> 
> ## estimate cause specific Cox model
> fitCR <-  CSC(Hist(time,event)~ X1+X8,data=dt,cause=1)
> 
> ## compute the ATE at times 1, 5, 10 using X1 as the treatment variable
> ateFit2a <- ate(fitCR, data = dt, treatment = "X1", times = c(1,5,10),
+                 cause = 1, se = TRUE, band = TRUE)
 Input variables 
 - Treatment            : X1 (3 levels: "T0" "T1" "T2")
 - Event                : event (cause: 1, competing risk(s): 2, censoring: 0)
 - Time  [min;max]      : time [0.0839;19.1]
 - Eval. time           :   1   5 10
      number at risk T0   263 106 12
      number at risk T1   160  57 11
      number at risk T2    26  15  3

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Processing
 - Prepare influence function: outcome done 
 - Point estimation: done 
 - Decomposition iid: done
 - Confidence intervals / bands: done
> summary(ateFit2a)
     Average treatment effect for cause 1 

 - Treatment            : X1 (3 levels: "T0" "T1" "T2")
 - Event                : event (cause: 1, competing risk(s): 2, censoring: 0)
 - Time  [min;max]      : time [0.0839;19.1]
 - Eval. time           :   1   5 10
      number at risk T0   263 106 12
      number at risk T1   160  57 11
      number at risk T2    26  15  3

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Testing procedure
 - Null hypothesis     : given two treatments (A,B), equal risks at all timepoints 
 - Confidence level    : 0.95
 - Multiple comparisons: single-step max-T adjustment computed using 10000 simulations

 Results: 
 - Difference in standardized risk (B-A) between time zero and 'time' 
                reported on the scale [-1;1] (difference between two probabilities)
 (difference in average risks when treating all subjects with the experimental treatment (B),
                                vs. treating all subjects with the reference treatment (A))

 time X1=A risk(X1=A) X1=B risk(X1=B) difference           ci p.value
    1   T0     0.0673   T1     0.0681   8.72e-04 [-0.02;0.02]   0.926
    5   T0     0.3744   T1     0.3743  -2.52e-05 [-0.08;0.08]   1.000
   10   T0     0.5017   T1     0.4935  -8.21e-03 [-0.10;0.09]   0.867
    1   T0     0.0673   T2     0.0523  -1.49e-02 [-0.05;0.02]   0.355
    5   T0     0.3744   T2     0.3063  -6.81e-02 [-0.22;0.09]   0.388
   10   T0     0.5017   T2     0.4253  -7.64e-02 [-0.27;0.12]   0.434
    1   T1     0.0681   T2     0.0523  -1.58e-02 [-0.05;0.02]   0.346
    5   T1     0.3743   T2     0.3063  -6.80e-02 [-0.23;0.09]   0.404
   10   T1     0.4935   T2     0.4253  -6.82e-02 [-0.27;0.13]   0.498
 simultaneous ci adjusted p.value
    [-0.02;0.02]            0.987
    [-0.09;0.09]            1.000
    [-0.11;0.09]            0.953
    [-0.05;0.02]            0.419
    [-0.23;0.10]            0.454
    [-0.28;0.13]            0.507
    [-0.05;0.02]            0.409
    [-0.24;0.10]            0.472
    [-0.28;0.14]            0.581

 difference      : estimated difference in standardized risks 
 ci              : pointwise confidence intervals 
 p.value         : (unadjusted) p-value 
 simultaneous ci : simulatenous confidence intervals over time
 adjusted p.value: p-value adjusted for multiple comparisons over time
> as.data.table(ateFit2a)
         type estimator time level      estimate          se       lower
 1:  meanRisk  GFORMULA    1    T0  6.725075e-02 0.012050231  0.04363273
 2:  meanRisk  GFORMULA    5    T0  3.743564e-01 0.027863621  0.31974466
 3:  meanRisk  GFORMULA   10    T0  5.017158e-01 0.032588024  0.43784440
 4:  meanRisk  GFORMULA    1    T1  6.812318e-02 0.012567904  0.04349054
 5:  meanRisk  GFORMULA    5    T1  3.743311e-01 0.034694830  0.30633052
 6:  meanRisk  GFORMULA   10    T1  4.935039e-01 0.039653201  0.41578504
 7:  meanRisk  GFORMULA    1    T2  5.232115e-02 0.018006403  0.01702925
 8:  meanRisk  GFORMULA    5    T2  3.062972e-01 0.075452662  0.15841267
 9:  meanRisk  GFORMULA   10    T2  4.253305e-01 0.093198889  0.24266407
10:  diffRisk  GFORMULA    1 T0.T1  8.724303e-04 0.009441589 -0.01763274
11:  diffRisk  GFORMULA    5 T0.T1 -2.520916e-05 0.041528106 -0.08141880
12:  diffRisk  GFORMULA   10 T0.T1 -8.211865e-03 0.049084017 -0.10441477
13:  diffRisk  GFORMULA    1 T0.T2 -1.492961e-02 0.016145110 -0.04657344
14:  diffRisk  GFORMULA    5 T0.T2 -6.805918e-02 0.078813390 -0.22253059
15:  diffRisk  GFORMULA   10 T0.T2 -7.638522e-02 0.097706198 -0.26788585
16:  diffRisk  GFORMULA    1 T1.T2 -1.580204e-02 0.016761368 -0.04865371
17:  diffRisk  GFORMULA    5 T1.T2 -6.803397e-02 0.081442901 -0.22765912
18:  diffRisk  GFORMULA   10 T1.T2 -6.817335e-02 0.100625523 -0.26539576
19: ratioRisk  GFORMULA    1 T0.T1  1.012973e+00 0.141191244  0.73624304
20: ratioRisk  GFORMULA    5 T0.T1  9.999327e-01 0.110929211  0.78251540
21: ratioRisk  GFORMULA   10 T0.T1  9.836324e-01 0.097205064  0.79311401
22: ratioRisk  GFORMULA    1 T0.T2  7.780009e-01 0.234968184  0.31747172
23: ratioRisk  GFORMULA    5 T0.T2  8.181968e-01 0.206945429  0.41259122
24: ratioRisk  GFORMULA   10 T0.T2  8.477520e-01 0.191990382  0.47145777
25: ratioRisk  GFORMULA    1 T1.T2  7.680373e-01 0.237987611  0.30159016
26: ratioRisk  GFORMULA    5 T1.T2  8.182519e-01 0.211754010  0.40322167
27: ratioRisk  GFORMULA   10 T1.T2  8.618585e-01 0.199975344  0.46991406
         type estimator time level      estimate          se       lower
         upper quantileBand   lowerBand  upperBand   p.value adj.p.value
 1: 0.09086877     2.317771  0.03932108 0.09518043        NA          NA
 2: 0.42896804     2.317771  0.30977486 0.43893784        NA          NA
 3: 0.56558711     2.317771  0.42618418 0.57724733        NA          NA
 4: 0.09275582     2.300197  0.03921453 0.09703183        NA          NA
 5: 0.44233176     2.300197  0.29452621 0.45413608        NA          NA
 6: 0.57122274     2.300197  0.40229373 0.58471405        NA          NA
 7: 0.08761305     2.173021  0.01319285 0.09144944        NA          NA
 8: 0.45418167     2.173021  0.14233695 0.47025739        NA          NA
 9: 0.60799700     2.173021  0.22280739 0.62785368        NA          NA
10: 0.01937760     2.077331 -0.01874087 0.02048573 0.9263779      0.9866
11: 0.08136838     2.077331 -0.08629282 0.08624240 0.9995157      1.0000
12: 0.08799104     2.077331 -0.11017560 0.09375187 0.8671323      0.9528
13: 0.01671423     2.100121 -0.04883630 0.01897708 0.3551148      0.4188
14: 0.08641222     2.100121 -0.23357685 0.09745849 0.3878360      0.4544
15: 0.11511541     2.100121 -0.28158008 0.12880964 0.4343411      0.5071
16: 0.01704964     2.101442 -0.05102508 0.01942101 0.3458009      0.4095
17: 0.09159118     2.101442 -0.23918153 0.10311359 0.4035162      0.4725
18: 0.12904905     2.101442 -0.27963209 0.14328538 0.4980915      0.5807
19: 1.28970255     2.090655  0.71779060 1.30815499 0.9267926      0.9851
20: 1.21734992     2.090655  0.76801794 1.23184738 0.9995156      1.0000
21: 1.17415086     2.090655  0.78041017 1.18685470 0.8662829      0.9563
22: 1.23853008     2.011050  0.30546805 1.25053374 0.3447585      0.3916
23: 1.22380239     2.011050  0.40201913 1.23437448 0.3796681      0.4292
24: 1.22404624     2.011050  0.46164968 1.23385433 0.4277790      0.4786
25: 1.23448445     2.024729  0.28617680 1.24989782 0.3297171      0.3747
26: 1.23328214     2.024729  0.38950734 1.24699647 0.3907278      0.4408
27: 1.25380300     2.024729  0.45696257 1.26675448 0.4896959      0.5518
         upper quantileBand   lowerBand  upperBand   p.value adj.p.value
> 
> #### Double robust estimator ####
> ## Not run: 
> ##D ## generate data
> ##D n <- 500
> ##D set.seed(10)
> ##D dt <- sampleData(n, outcome="competing.risks")
> ##D dt$time <- round(dt$time,1)
> ##D dt$X1 <- factor(rbinom(n, prob = c(0.4) , size = 1), labels = paste0("T",0:1))
> ##D 
> ##D ## working models
> ##D m.event <-  CSC(Hist(time,event)~ X1+X2+X3+X5+X8,data=dt)
> ##D m.censor <-  coxph(Surv(time,event==0)~ X1+X2+X3+X5+X8,data=dt, x = TRUE, y = TRUE)
> ##D m.treatment <-  glm(X1~X2+X3+X5+X8,data=dt,family=binomial(link="logit"))
> ##D 
> ##D ## prediction + average
> ##D ateRobust <- ate(event = m.event,
> ##D                  treatment = m.treatment,
> ##D                  censor = m.censor,
> ##D                  data = dt, times = 5:10, 
> ##D                  cause = 1, band = TRUE)
> ##D 
> ##D ## compare various estimators
> ##D ateRobust3 <- ate(event = m.event,
> ##D                  treatment = m.treatment,
> ##D                  censor = m.censor,
> ##D                  estimator = c("GFORMULA","IPTW","AIPTW"),
> ##D                  data = dt, times = c(5:10), 
> ##D                  cause = 1, se = TRUE)
> ##D print(setkeyv(as.data.table(ateRobust3, type = "meanRisk"),"time"))
> ##D print(setkeyv(as.data.table(ateRobust3, type = "diffRisk"),"time"))
> ## End(Not run)
> 
> #### time-dependent covariates ###
> ## Not run: 
> ##D library(survival)
> ##D fit <- coxph(Surv(time, status) ~ celltype+karno + age + trt, veteran)
> ##D vet2 <- survSplit(Surv(time, status) ~., veteran,
> ##D                        cut=c(60, 120), episode ="timegroup")
> ##D fitTD <- coxph(Surv(tstart, time, status) ~ celltype+karno + age + trt,
> ##D                data= vet2,x=1)
> ##D set.seed(16)
> ##D resVet <- ate(fitTD,formula=Hist(entry=tstart,time=time,event=status)~1,
> ##D           data = vet2, treatment = "celltype",
> ##D         times=5,verbose=1,
> ##D         landmark = c(0,30,60,90), cause = 1, B = 50, se = 1,
> ##D         band = FALSE, mc.cores=1)
> ##D summary(resVet)
> ## End(Not run)
> 
> ## Not run: 
> ##D set.seed(137)
> ##D d=sampleDataTD(127)
> ##D library(survival)
> ##D d[,status:=1*(event==1)]
> ##D d[,X3:=as.factor(X3)]
> ##D ## ignore competing risks
> ##D cox1TD <- coxph(Surv(start,time, status,type="counting") ~ X3+X5+X6+X8,
> ##D                 data=d, x = TRUE)
> ##D resTD1 <- ate(cox1TD,formula=Hist(entry=start,time=time,event=status)~1,
> ##D         data = d, treatment = "X3", contrasts = NULL,
> ##D         times=.5,verbose=1,
> ##D         landmark = c(0,0.5,1), B = 20, se = 1,
> ##D         band = FALSE, mc.cores=1)
> ##D resTD1
> ##D ## account for competing risks
> ##D cscTD <- CSC(Hist(time=time, event=event,entry=start) ~ X3+X5+X6+X8, data=d)
> ##D set.seed(16)
> ##D resTD <- ate(cscTD,formula=Hist(entry=start,time=time,event=event)~1,
> ##D         data = d, treatment = "X3", contrasts = NULL,
> ##D         times=.5,verbose=1,
> ##D         landmark = c(0,0.5,1), cause = 1, B = 20, se = 1,
> ##D         band = FALSE, mc.cores=1)
> ##D resTD
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:prodlim’, ‘package:rms’,
  ‘package:SparseM’, ‘package:Hmisc’, ‘package:ggplot2’,
  ‘package:Formula’, ‘package:lattice’, ‘package:survival’

> nameEx("autoplot.Score")
> ### * autoplot.Score
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.Score
> ### Title: ggplot AUC curve
> ### Aliases: autoplot.Score
> 
> ### ** Examples
> 
> library(survival)
> library(ggplot2)
> d=sampleData(100,outcome="survival")
> nd=sampleData(100,outcome="survival")
> f1=coxph(Surv(time,event)~X1+X6+X8,data=d,x=TRUE,y=TRUE)
> f2=coxph(Surv(time,event)~X2+X5+X9,data=d,x=TRUE,y=TRUE)
> xx=Score(list(f1,f2), formula=Surv(time,event)~1,
+ data=nd, metrics="auc", null.model=FALSE, times=seq(3:10))
> g <- autoplot(xx)
> print(g)
> aucgraph <- plotAUC(xx)
> plotAUC(xx,conf.int=TRUE)
> plotAUC(xx,which="contrasts")
> plotAUC(xx,which="contrasts",conf.int=TRUE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:survival’

> nameEx("autoplot.ate")
> ### * autoplot.ate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.ate
> ### Title: Plot Average Risks
> ### Aliases: autoplot.ate
> 
> ### ** Examples
> 
> library(survival)
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> library(ggplot2)
> 
> #### simulate data ####
> n <- 1e2
> set.seed(10)
> dtS <- sampleData(n,outcome="survival")
> seqTimes <- c(0,sort(dtS$time[dtS$event==1]),max(dtS$time))
> 
> #### Cox model ####
> fit <- cph(formula = Surv(time,event)~ X1+X2,data=dtS,y=TRUE,x=TRUE)
> 
> #### plot.type = 1: for few timepoints ####
> ateFit <- ate(fit, data = dtS, treatment = "X1",
+               times = c(1,2,5,10), se = TRUE, band = TRUE)
 Input variables 
 - Treatment            : X1 (2 levels: "0" "1")
 - Event                : event (cause: 1, censoring: 0)
 - Time  [min;max]      : time [0.64;15.7]
 - Eval. time          :  1  2  5 10
      number at risk 0   83 77 45  7
      number at risk 1   12  9  4  3

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Processing
 - Prepare influence function: outcome done 
 - Point estimation: done 
 - Decomposition iid: done
 - Confidence intervals / bands: done
> ggplot2::autoplot(ateFit)
> ggplot2::autoplot(ateFit, band = FALSE)
> ggplot2::autoplot(ateFit, type = "diffRisk")
> ggplot2::autoplot(ateFit, type = "ratioRisk")
> 
> #### plot.type = 2: when looking at all jump times ####
> ateFit <- ate(fit, data = dtS, treatment = "X1",
+               times = seqTimes, se = TRUE, band = TRUE)
 Input variables 
 - Treatment            : X1 (2 levels: "0" "1")
 - Event                : event (cause: 1, censoring: 0)
 - Time  [min;max]      : time [0.64;15.7]
 - Eval. time          :  0 0.639814986469106 0.693329164093973
      number at risk 0   85                85                85
      number at risk 1   15                15                14
 0.73471808044227 0.895332913345022 0.911273931856863 1.20991283758876
               85                84                84               83
               13                13                12               12
 1.6295250799355 1.63611343834339 1.72526511337677 1.73636273373706
              83               82               82               81
              11               11               10               10
 1.74851221735561 1.80493524120624 1.91882708464043 2.12621832419541
               80               79               79               77
               10               10                9                9
 2.23340144006609 2.61361517854674 2.63360035533507 2.78189482191137
               76               74               73               72
                8                8                8                8
 2.86778140290141 2.96291474905232 3.04488596459 3.09086748851789
               71               71            70               69
                8                7             7                7
 3.16518242893387 3.21368140182021 3.27721630181111 3.33975995010388
               68               67               65               64
                7                7                7                7
 3.59253190754745 3.60000469311398 3.60086785208817 3.67227467641267
               63               62               62               61
                7                7                6                6
 3.75513325805154 4.01529738856792 4.07066480647231 4.25368441764723
               61               58               57               54
                5                5                5                5
 4.26154805041596 4.35631523787514 4.35651033185808 4.37599712311764
               54               53               52               51
                4                4                4                4
 4.41066136347203 4.76396413451789 4.80926511899524 5.05204894237525
               50               47               46               44
                4                4                4                4
 5.29134554122288 5.55543384398437 5.63004000600479 5.69020347041744
               41               39               38               37
                4                4                4                4
 5.71639662948036 6.3184300751255 6.76838601303312 6.92201658244423
               36              32               29               29
                4               4                4                3
 7.00532162800279 7.17919858399676 7.26700563806158 8.33077171167021
               27               26               23               14
                3                3                3                3
 9.11609653715864 10.1094063281172 15.6955588202701
               11                7                1
                3                3                0

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Processing
 - Prepare influence function: outcome done 
 - Point estimation: done 
 - Decomposition iid: done
 - Confidence intervals / bands: done
> 
> ggplot2::autoplot(ateFit, plot.type = "2")
> 
> ## customize plot
> outGG <- ggplot2::autoplot(ateFit, plot.type = "2", alpha = 0.25)
> outGG$plot + facet_wrap(~X1, labeller = label_both)
> 
> 
> ## Looking at the difference after smoothing
> ## Not run: 
> ##D outGGS <- ggplot2::autoplot(ateFit, plot.type = "2", alpha = NA, smooth = TRUE)
> ##D outGGS$plot + facet_wrap(~X1, labeller = label_both)
> ## End(Not run)
> 
> ## first derivative
> ## (computation of the confidence intervals takes time)
> ## (based on simulation - n.sim parameter)
> ## Not run: 
> ##D  
> ##D ggplot2::autoplot(ateFit, plot.type = "2", smooth = TRUE,
> ##D                   band = FALSE, type = "diffRisk")
> ##D ggplot2::autoplot(ateFit, plot.type = "2", smooth = TRUE, first.derivative = TRUE,
> ##D                   band = FALSE, type = "diffRisk")
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:rms’, ‘package:SparseM’, ‘package:Hmisc’,
  ‘package:ggplot2’, ‘package:Formula’, ‘package:lattice’,
  ‘package:survival’

> nameEx("autoplot.predictCSC")
> ### * autoplot.predictCSC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.predictCSC
> ### Title: Plot Predictions From a Cause-specific Cox Proportional Hazard
> ###   Regression
> ### Aliases: autoplot.predictCSC
> 
> ### ** Examples
> 
> library(survival)
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> library(ggplot2)
> library(prodlim)
> 
> #### simulate data ####
> set.seed(10)
> d <- sampleData(1e2, outcome = "competing.risks")
> seqTau <- c(0,unique(sort(d[d$event==1,time])), max(d$time))
> 
> #### CSC model ####
> m.CSC <- CSC(Hist(time,event)~ X1 + X2 + X6, data = d)
> 
> pred.CSC <- predict(m.CSC, newdata = d[1:2,], time = seqTau, cause = 1, band = TRUE)
> autoplot(pred.CSC, alpha = 0.2)
> 
> #### stratified CSC model ####
> m.SCSC <- CSC(Hist(time,event)~ strata(X1) + strata(X2) + X6,
+               data = d)
> pred.SCSC <- predict(m.SCSC, time = seqTau, newdata = d[1:4,],
+                      cause = 1, keep.newdata = TRUE, keep.strata = TRUE)
> autoplot(pred.SCSC, group.by = "strata")
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:rms’, ‘package:SparseM’,
  ‘package:Hmisc’, ‘package:ggplot2’, ‘package:Formula’,
  ‘package:lattice’, ‘package:survival’

> nameEx("autoplot.predictCox")
> ### * autoplot.predictCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: autoplot.predictCox
> ### Title: Plot Predictions From a Cox Model
> ### Aliases: autoplot.predictCox
> 
> ### ** Examples
> 
> library(survival)
> library(ggplot2)
> 
> #### simulate data ####
> set.seed(10)
> d <- sampleData(1e2, outcome = "survival")
> seqTau <- c(0,sort(unique(d$time[d$event==1])), max(d$time))
> 
> #### Cox model ####
> m.cox <- coxph(Surv(time,event)~ X1 + X2 + X3,
+                 data = d, x = TRUE, y = TRUE)
> 
> ## display baseline hazard
> e.basehaz <- predictCox(m.cox)
> autoplot(e.basehaz, type = "cumhazard")
> autoplot(e.basehaz, type = "cumhazard", smooth = TRUE)
Loading required namespace: mgcv
> autoplot(e.basehaz, type = "cumhazard", smooth = TRUE, first.derivative = TRUE)
> 
> ## display baseline hazard with type of event 
> e.basehaz <- predictCox(m.cox, keep.newdata = TRUE)
> autoplot(e.basehaz, type = "cumhazard")
> 
> ## display predicted survival
> pred.cox <- predictCox(m.cox, newdata = d[1:2,],
+   times = seqTau, type = "survival", keep.newdata = TRUE)
> autoplot(pred.cox)
> autoplot(pred.cox, smooth = TRUE)
> autoplot(pred.cox, group.by = "covariates")
> autoplot(pred.cox, group.by = "covariates", reduce.data = TRUE)
> 
> 
> ## predictions with confidence interval/bands
> pred.cox <- predictCox(m.cox, newdata = d[1:2,,drop=FALSE],
+   times = seqTau, type = "survival", band = TRUE, se = TRUE, keep.newdata = TRUE)
> res <- autoplot(pred.cox, ci = TRUE, band = TRUE, plot = FALSE)
> res$plot + facet_wrap(~row)
> res2 <- autoplot(pred.cox, ci = TRUE, band = TRUE, alpha = 0.1, plot = FALSE)
> res2$plot + facet_wrap(~row)
> 
> #### Stratified Cox model ####
> m.cox.strata <- coxph(Surv(time,event)~ strata(X1) + strata(X2) + X3 + X4,
+                       data = d, x = TRUE, y = TRUE)
> 
> ## baseline hazard
> pred.baseline <- predictCox(m.cox.strata, keep.newdata = TRUE, type = "survival")
> res <- autoplot(pred.baseline)
> res$plot + facet_wrap(~strata, labeller = label_both)
> 
> ## predictions
> pred.cox.strata <- predictCox(m.cox.strata, newdata = d[1:5,,drop=FALSE],
+                               time = seqTau, keep.newdata = TRUE, se = TRUE)
> 
> res2 <- autoplot(pred.cox.strata, type = "survival", group.by = "strata", plot = FALSE)
> res2$plot + facet_wrap(~strata, labeller = label_both) + theme(legend.position="bottom")
> 
> ## smooth version
> autoplot(pred.cox.strata, type = "survival", group.by = "strata", smooth = TRUE, ci = FALSE)
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:survival’

> nameEx("boot2pvalue")
> ### * boot2pvalue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boot2pvalue
> ### Title: Compute the p.value from the distribution under H1
> ### Aliases: boot2pvalue
> 
> ### ** Examples
> 
> set.seed(10)
> 
> #### no effect ####
> x <- rnorm(1e3) 
> boot2pvalue(x, null = 0, estimate = mean(x), alternative = "two.sided")
Warning in boot2pvalue(x, null = 0, estimate = mean(x), alternative = "two.sided") :
  incorrect convergence of the algorithm finding the critical quantile 
p-value may not be reliable 

[1] 0.999
> ## expected value of 1
> boot2pvalue(x, null = 0, estimate = mean(x), alternative = "greater")
[1] 0.5
> ## expected value of 0.5
> boot2pvalue(x, null = 0, estimate = mean(x), alternative = "less")
[1] 0.5
> ## expected value of 0.5
> 
> #### positive effect ####
> x <- rnorm(1e3, mean = 1) 
> boot2pvalue(x, null = 0, estimate = 1, alternative = "two.sided")
[1] 0.336
> ## expected value of 0.32 = 2*pnorm(q = 0, mean = -1) = 2*mean(x<=0)
> boot2pvalue(x, null = 0, estimate = 1, alternative = "greater")  
[1] 0.168
> ## expected value of 0.16 = pnorm(q = 0, mean = 1) = mean(x<=0)
> boot2pvalue(x, null = 0, estimate = 1, alternative = "less")
[1] 0.832
> ## expected value of 0.84 = 1-pnorm(q = 0, mean = 1) = mean(x>=0)
> 
> #### negative effect ####
> x <- rnorm(1e3, mean = -1) 
> boot2pvalue(x, null = 0, estimate = -1, alternative = "two.sided") 
[1] 0.301
> ## expected value of 0.32 = 2*(1-pnorm(q = 0, mean = -1)) = 2*mean(x>=0)
> boot2pvalue(x, null = 0, estimate = -1, alternative = "greater")
[1] 0.849
> ## expected value of 0.84 = pnorm(q = 0, mean = -1) = mean(x<=0)
> boot2pvalue(x, null = 0, estimate = -1, alternative = "less") # pnorm(q = 0, mean = -1)
[1] 0.151
> ## expected value of 0.16 = 1-pnorm(q = 0, mean = -1) = mean(x>=0)
> 
> 
> 
> cleanEx()
> nameEx("boxplot.Score")
> ### * boxplot.Score
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: boxplot.Score
> ### Title: Boxplot risk quantiles
> ### Aliases: boxplot.Score
> 
> ### ** Examples
> 
> # binary outcome
> library(data.table)
> library(prodlim)
> db=sampleData(40,outcome="binary")
> fitconv=glm(Y~X3+X5,data=db,family=binomial)
> fitnew=glm(Y~X1+X3+X5+X6+X7,data=db,family=binomial)
> x=Score(list(new=fitnew,conv=fitconv),
+         formula=Y~1,contrasts=list(c(2,1)),
+                data=db,plots="box",null.model=FALSE)
> boxplot(x)
> 
> # survival outcome
> library(survival)
> ds=sampleData(40,outcome="survival")
> fit=coxph(Surv(time,event)~X6+X9,data=ds,x=TRUE,y=TRUE)
> ## Not run: 
> ##D  
> ##D scoreobj=Score(list("Cox"=fit),
> ##D                 formula=Hist(time,event)~1, data=ds,
> ##D                 metrics=NULL, plots="box",
> ##D                 times=c(1,5),null.model=FALSE)
> ##D boxplot(scoreobj,timepoint=5)
> ##D boxplot(scoreobj,timepoint=1)
> ##D 
> ## End(Not run)
> 
> # competing risks outcome
> library(survival)
> data(Melanoma, package = "riskRegression")
> fit = CSC(Hist(time,event,cens.code="censored")~invasion+age+sex,data=Melanoma)
Warning in FUN(X[[i]], ...) :
  Variables named status in data will be ignored.
Warning in FUN(X[[i]], ...) :
  Variables named status in data will be ignored.
> scoreobj=Score(list("CSC"=fit),
+                formula=Hist(time,event,cens.code="censored")~1,
+                data=Melanoma,plots="box",times=5*365.25,null.model=FALSE)
> par(mar=c(4,12,4,4))
> boxplot(scoreobj,timepoint=5*365.25)
> 
> # more than 2 competing risks
> m=lava::lvm(~X1+X2+X3)
> lava::distribution(m, "eventtime1") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::distribution(m, "eventtime2") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::distribution(m, "eventtime3") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::distribution(m, "censtime") <- lava::coxWeibull.lvm(scale = 1/100)
> lava::regression(m,eventtime2~X3)=1.3
> m <- lava::eventTime(m,
+ time ~ min(eventtime1 = 1, eventtime2 = 2, eventtime3 = 3, censtime = 0), "event")
> set.seed(101)
> dcr=as.data.table(lava::sim(m,101))
> fit = CSC(Hist(time,event)~X1+X2+X3,data=dcr)
> scoreobj=Score(list("my model"=fit),
+                formula=Hist(time,event)~1,
+                data=dcr,plots="box",times=5,null.model=FALSE)
> boxplot(scoreobj)
> 
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’, ‘package:data.table’

> nameEx("colCenter_cpp")
> ### * colCenter_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colCenter_cpp
> ### Title: Apply - by column
> ### Aliases: colCenter_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 1, FUN = "-", STATS = 1:6)
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]   -1   -1   -1   -1   -1
[3,]   -2   -2   -2   -2   -2
[4,]   -3   -3   -3   -3   -3
[5,]   -4   -4   -4   -4   -4
[6,]   -5   -5   -5   -5   -5
> colCenter_cpp(x, 1:6 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]   -1   -1   -1   -1   -1
[3,]   -2   -2   -2   -2   -2
[4,]   -3   -3   -3   -3   -3
[5,]   -4   -4   -4   -4   -4
[6,]   -5   -5   -5   -5   -5
> 
> 
> 
> cleanEx()
> nameEx("colCumProd")
> ### * colCumProd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colCumProd
> ### Title: Apply cumprod in each column
> ### Aliases: colCumProd
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> colCumProd(x)
     [,1] [,2]
[1,]    1    5
[2,]    2   30
[3,]    6  210
[4,]   24 1680
> 
> 
> 
> cleanEx()
> nameEx("colCumSum")
> ### * colCumSum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colCumSum
> ### Title: Apply cumsum in each column
> ### Aliases: colCumSum
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> colCumSum(x)
     [,1] [,2]
[1,]    1    5
[2,]    3   11
[3,]    6   18
[4,]   10   26
> 
> 
> 
> cleanEx()
> nameEx("colMultiply_cpp")
> ### * colMultiply_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colMultiply_cpp
> ### Title: Apply * by column
> ### Aliases: colMultiply_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 1, FUN = "*", STATS = 1:6)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    2    2    2    2    2
[3,]    3    3    3    3    3
[4,]    4    4    4    4    4
[5,]    5    5    5    5    5
[6,]    6    6    6    6    6
> colMultiply_cpp(x, 1:6 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    2    2    2    2    2
[3,]    3    3    3    3    3
[4,]    4    4    4    4    4
[5,]    5    5    5    5    5
[6,]    6    6    6    6    6
> 
> 
> 
> cleanEx()
> nameEx("colScale_cpp")
> ### * colScale_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colScale_cpp
> ### Title: Apply / by column
> ### Aliases: colScale_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 1, FUN = "/", STATS = 1:6)
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[2,] 0.5000000 0.5000000 0.5000000 0.5000000 0.5000000
[3,] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333
[4,] 0.2500000 0.2500000 0.2500000 0.2500000 0.2500000
[5,] 0.2000000 0.2000000 0.2000000 0.2000000 0.2000000
[6,] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667
> colScale_cpp(x, 1:6 )
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 1.0000000 1.0000000 1.0000000 1.0000000 1.0000000
[2,] 0.5000000 0.5000000 0.5000000 0.5000000 0.5000000
[3,] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333
[4,] 0.2500000 0.2500000 0.2500000 0.2500000 0.2500000
[5,] 0.2000000 0.2000000 0.2000000 0.2000000 0.2000000
[6,] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667
> 
> 
> 
> cleanEx()
> nameEx("colSumsCrossprod")
> ### * colSumsCrossprod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: colSumsCrossprod
> ### Title: Apply crossprod and colSums
> ### Aliases: colSumsCrossprod
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> y <- matrix(1:16,ncol=8)
> colSumsCrossprod(x,y,0)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]   62  134  206  278  350  422  494  566
> 
> x <- matrix(1:8,ncol=2)
> y <- matrix(1:16,ncol=2)
> colSumsCrossprod(x,y,1)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]  244  280  316  352  388  424  460  496
> 
> 
> 
> cleanEx()
> nameEx("confint.ate")
> ### * confint.ate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.ate
> ### Title: Confidence Intervals and Confidence Bands for the Predicted
> ###   Absolute Risk (Cumulative Incidence Function)
> ### Aliases: confint.ate
> 
> ### ** Examples
> 
> library(survival)
> library(data.table)
> 
> ## ## generate data ####
> set.seed(10)
> d <- sampleData(70,outcome="survival")
> d[, X1 := paste0("T",rbinom(.N, size = 2, prob = c(0.51)))]
> ## table(d$X1)
> 
> #### stratified Cox model ####
> fit <- coxph(Surv(time,event)~X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> #### average treatment effect ####
> fit.ate <- ate(fit, treatment = "X1", times = 1:3, data = d,
+                se = TRUE, iid = TRUE, band = TRUE)
 Input variables 
 - Treatment            : X1 (3 levels: "T0" "T1" "T2")
 - Event                : event (cause: 1, censoring: 0)
 - Time  [min;max]      : time [0.499;20.6]
 - Eval. time           :  1  2  3
      number at risk T0   10 10 10
      number at risk T1   29 24 23
      number at risk T2   28 24 20

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Processing
 - Prepare influence function: outcome done 
 - Point estimation: done 
 - Decomposition iid: done
 - Confidence intervals / bands: done
> summary(fit.ate)
     Average treatment effect 

 - Treatment            : X1 (3 levels: "T0" "T1" "T2")
 - Event                : event (cause: 1, censoring: 0)
 - Time  [min;max]      : time [0.499;20.6]
 - Eval. time           :  1  2  3
      number at risk T0   10 10 10
      number at risk T1   29 24 23
      number at risk T2   28 24 20

 Estimation procedure 
 - Estimator  : G-formula
 - Uncertainty: Gaussian approximation 
                where the variance is estimated via the influence function 

 Testing procedure
 - Null hypothesis     : given two treatments (A,B), equal risks at all timepoints 
 - Confidence level    : 0.95
 - Multiple comparisons: single-step max-T adjustment computed using 10000 simulations

 Results: 
 - Difference in standardized risk (B-A) between time zero and 'time' 
                reported on the scale [-1;1] (difference between two probabilities)
 (difference in average risks when treating all subjects with the experimental treatment (B),
                                vs. treating all subjects with the reference treatment (A))

 time X1=A risk(X1=A) X1=B risk(X1=B) difference           ci p.value
    1   T0     0.0339   T1     0.0472    0.01332 [-0.02;0.05]   0.411
    2   T0     0.1352   T1     0.1826    0.04739 [-0.07;0.17]   0.431
    3   T0     0.1703   T1     0.2267    0.05642 [-0.08;0.20]   0.432
    1   T0     0.0339   T2     0.0420    0.00815 [-0.02;0.03]   0.506
    2   T0     0.1352   T2     0.1645    0.02933 [-0.07;0.12]   0.545
    3   T0     0.1703   T2     0.2054    0.03511 [-0.08;0.15]   0.551
    1   T1     0.0472   T2     0.0420   -0.00518 [-0.04;0.03]   0.764
    2   T1     0.1826   T2     0.1645   -0.01806 [-0.13;0.10]   0.759
    3   T1     0.2267   T2     0.2054   -0.02131 [-0.16;0.11]   0.758
 simultaneous ci adjusted p.value
    [-0.02;0.05]            0.504
    [-0.08;0.18]            0.525
    [-0.10;0.21]            0.526
    [-0.02;0.03]            0.590
    [-0.07;0.13]            0.630
    [-0.09;0.16]            0.636
    [-0.04;0.03]            0.811
    [-0.14;0.10]            0.806
    [-0.16;0.12]            0.805

 difference      : estimated difference in standardized risks 
 ci              : pointwise confidence intervals 
 p.value         : (unadjusted) p-value 
 simultaneous ci : simulatenous confidence intervals over time
 adjusted p.value: p-value adjusted for multiple comparisons over time
> dt.ate <- as.data.table(fit.ate)
> 
> ## manual calculation of se
> dd <- copy(d)
> dd$X1 <- rep(factor("T0", levels = paste0("T",0:2)), NROW(dd))
> out <- predictCox(fit, newdata = dd, se = TRUE, times = 1:3, average.iid = TRUE)
> term1 <- -out$survival.average.iid
> term2 <- sweep(1-out$survival, MARGIN = 2, FUN = "-", STATS = colMeans(1-out$survival))
> sqrt(colSums((term1 + term2/NROW(d))^2)) 
[1] 0.02557002 0.05576405 0.06256730
> ## fit.ate$meanRisk[treatment=="T0",se]
> 
> ## note
> out2 <- predictCox(fit, newdata = dd, se = TRUE, times = 1:3, iid = TRUE)
> mean(out2$survival.iid[1,1,])
[1] -0.0003529296
> out$survival.average.iid[1,1]
[1] -0.0003529296
> 
> ## check confidence intervals (no transformation)
> dt.ate[,.(lower = pmax(0,estimate + qnorm(0.025) * se),
+           lower2 = lower,
+           upper = estimate + qnorm(0.975) * se,
+           upper2 = upper)]
         lower      lower2      upper     upper2
 1: 0.00000000  0.00000000 0.08401352 0.08401352
 2: 0.02590437  0.02590437 0.24449544 0.24449544
 3: 0.04767637  0.04767637 0.29293567 0.29293567
 4: 0.00000000  0.00000000 0.10199266 0.10199266
 5: 0.06587254  0.06587254 0.29931345 0.29931345
 6: 0.09787653  0.09787653 0.35557496 0.35557496
 7: 0.00000000  0.00000000 0.08763162 0.08763162
 8: 0.07373281  0.07373281 0.25532659 0.25532659
 9: 0.10169224  0.10169224 0.30914481 0.30914481
10: 0.00000000 -0.01843023 0.04508014 0.04508014
11: 0.00000000 -0.07044632 0.16523250 0.16523250
12: 0.00000000 -0.08418721 0.19702666 0.19702666
13: 0.00000000 -0.01583434 0.03212551 0.03212551
14: 0.00000000 -0.06563720 0.12429679 0.12429679
15: 0.00000000 -0.08028787 0.15051289 0.15051289
16: 0.00000000 -0.03892565 0.02856692 0.02856692
17: 0.00000000 -0.13355386 0.09742727 0.09742727
18: 0.00000000 -0.15680088 0.11418644 0.11418644
19: 0.21268856  0.21268856 2.57350940 2.57350940
20: 0.31415598  0.31415598 2.38692575 2.38692575
21: 0.35840663  0.35840663 2.30416217 2.30416217
22: 0.32511683  0.32511683 2.15548849 2.15548849
23: 0.39528481  0.39528481 2.03858823 2.03858823
24: 0.42753998  0.42753998 1.98480606 1.98480606
25: 0.23798475  0.23798475 1.54265349 1.54265349
26: 0.31071769  0.31071769 1.49142922 1.49142922
27: 0.34410983  0.34410983 1.46793427 1.46793427
         lower      lower2      upper     upper2
> 
> ## add confidence intervals computed on the log-log scale
> ## and backtransformed
> outCI <- confint(fit.ate,
+                  meanRisk.transform = "loglog", diffRisk.transform = "atanh",
+                  ratioRisk.transform = "log")
> summary(outCI, type = "risk", short = TRUE)
                       Length Class      Mode     
meanRisk               10     data.table list     
diffRisk               15     data.table list     
ratioRisk              15     data.table list     
inference              12     data.frame list     
inference.allContrasts  6     -none-     character
inference.contrasts     3     -none-     character
transform               3     -none-     character
> 
> dt.ate[type == "meanRisk", newse := se/(estimate*log(estimate))]
> dt.ate[type == "meanRisk", .(lower = exp(-exp(log(-log(estimate)) - 1.96 * newse)),
+                         upper = exp(-exp(log(-log(estimate)) + 1.96 * newse)))]
         lower     upper
1: 0.005308092 0.1123030
2: 0.049930563 0.2629084
3: 0.070036723 0.3077237
4: 0.011517821 0.1239456
5: 0.084038215 0.3110947
6: 0.113440244 0.3635412
7: 0.011538684 0.1053196
8: 0.086275187 0.2646901
9: 0.113322713 0.3165183
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:survival’

> nameEx("confint.predictCSC")
> ### * confint.predictCSC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.predictCSC
> ### Title: Confidence Intervals and Confidence Bands for the Predicted
> ###   Absolute Risk (Cumulative Incidence Function)
> ### Aliases: confint.predictCSC
> 
> ### ** Examples
> 
> library(survival)
> library(prodlim)
> #### generate data ####
> set.seed(10)
> d <- sampleData(100) 
> 
> #### estimate a stratified CSC model ###
> fit <- CSC(Hist(time,event)~ X1 + strata(X2) + X6, data=d)
> 
> #### compute individual specific risks
> fit.pred <- predict(fit, newdata=d[1:3], times=c(3,8), cause = 1,
+                     se = TRUE, iid = TRUE, band = TRUE)
> fit.pred
   observation X1   X6 times strata absRisk absRisk.se absRisk.lower
1:           1  1 30.8     3   X2=1   0.138     0.0785        0.0311
2:           2  0 66.3     3   X2=1   0.456     0.1247        0.2114
3:           3  0 77.6     3   X2=1   0.799     0.1285        0.4007
4:           1  1 30.8     8   X2=1   0.298     0.1365        0.0788
5:           2  0 66.3     8   X2=1   0.803     0.0900        0.5503
6:           3  0 77.6     8   X2=1   0.954     0.0659        0.4310
   absRisk.upper absRisk.quantileBand absRisk.lowerBand absRisk.upperBand
1:         0.324                 2.15            0.0255             0.344
2:         0.673                 2.21            0.1832             0.695
3:         0.946                 2.15            0.3498             0.953
4:         0.562                 2.15            0.0649             0.585
5:         0.923                 2.21            0.5067             0.932
6:         0.997                 2.15            0.3266             0.998
> 
> ## check confidence intervals
> newse <- fit.pred$absRisk.se/(-fit.pred$absRisk*log(fit.pred$absRisk))
> cbind(lower = as.double(exp(-exp(log(-log(fit.pred$absRisk)) + 1.96 * newse))),
+       upper = as.double(exp(-exp(log(-log(fit.pred$absRisk)) - 1.96 * newse)))
+ )
          lower     upper
[1,] 0.03106980 0.3237727
[2,] 0.21142317 0.6725332
[3,] 0.40068902 0.9463311
[4,] 0.07874874 0.5616676
[5,] 0.55031414 0.9226697
[6,] 0.43098190 0.9973992
> 
> #### compute confidence intervals without transformation
> confint(fit.pred, absRisk.transform = "none")
   observation X1   X6 times strata absRisk absRisk.se absRisk.lower
1:           1  1 30.8     3   X2=1   0.138     0.0785        0.0000
2:           2  0 66.3     3   X2=1   0.456     0.1247        0.2116
3:           3  0 77.6     3   X2=1   0.799     0.1285        0.5469
4:           1  1 30.8     8   X2=1   0.298     0.1365        0.0305
5:           2  0 66.3     8   X2=1   0.803     0.0900        0.6267
6:           3  0 77.6     8   X2=1   0.954     0.0659        0.8252
   absRisk.upper absRisk.quantileBand absRisk.lowerBand absRisk.upperBand
1:         0.292                 2.14           0.00000             0.306
2:         0.700                 2.23           0.17842             0.734
3:         1.000                 2.17           0.51970             1.000
4:         0.565                 2.14           0.00656             0.589
5:         0.980                 2.23           0.60269             1.000
6:         1.000                 2.17           0.81125             1.000
> cbind(lower = as.double(fit.pred$absRisk - 1.96 * fit.pred$absRisk.se),
+       upper = as.double(fit.pred$absRisk + 1.96 * fit.pred$absRisk.se)
+ )
           lower     upper
[1,] -0.01553676 0.2920606
[2,]  0.21161883 0.7004983
[3,]  0.54689863 1.0507549
[4,]  0.03045984 0.5654551
[5,]  0.62665840 0.9795842
[6,]  0.82518445 1.0833380
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("confint.predictCox")
> ### * confint.predictCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.predictCox
> ### Title: Confidence Intervals and Confidence Bands for the predicted
> ###   Survival/Cumulative Hazard
> ### Aliases: confint.predictCox
> 
> ### ** Examples
> 
> library(survival)
> 
> #### generate data ####
> set.seed(10)
> d <- sampleData(40,outcome="survival") 
> 
> #### estimate a stratified Cox model ####
> fit <- coxph(Surv(time,event)~X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> #### compute individual specific survival probabilities  
> fit.pred <- predictCox(fit, newdata=d[1:3], times=c(3,8), type = "survival",
+                        se = TRUE, iid = TRUE, band = TRUE)
> fit.pred
   observation strata times survival survival.se survival.lower survival.upper
1:           1      0     3    0.830      0.0598          0.672          0.917
2:           2      0     3    0.878      0.0510          0.732          0.947
3:           3      0     3    0.975      0.0194          0.888          0.995
4:           1      0     8    0.441      0.1062          0.233          0.631
5:           2      0     8    0.564      0.1131          0.320          0.750
6:           3      0     8    0.894      0.0692          0.648          0.972
   survival.quantileBand survival.lowerBand survival.upperBand
1:                  2.24              0.642              0.925
2:                  2.22              0.704              0.953
3:                  2.13              0.873              0.995
4:                  2.24              0.205              0.654
5:                  2.22              0.287              0.769
6:                  2.13              0.613              0.975
> 
> ## check standard error
> sqrt(rowSums(fit.pred$survival.iid[,,1]^2)) ## se for individual 1
 [1] 0.018392578 0.016237776 0.007431816 0.012893439 0.025032667 0.005398069
 [7] 0.025666528 0.005026215 0.020439989 0.013954960 0.020245964 0.012961149
[13] 0.010320665 0.022387257 0.003809652 0.037842644 0.013409129 0.010237400
[19] 0.017079206 0.014556417 0.004868714 0.013372745 0.051035469 0.019664220
[25] 0.023187719 0.013702212 0.001694092 0.020826096 0.002277766 0.060597775
[31] 0.015962232 0.011798179 0.008106319 0.004469016 0.004496629 0.002184175
[37] 0.007678302 0.000496456 0.002440726 0.008088248
> 
> ## check confidence interval
> newse <- fit.pred$survival.se/(-fit.pred$survival*log(fit.pred$survival))
> cbind(lower = as.double(exp(-exp(log(-log(fit.pred$survival)) + 1.96 * newse))),
+       upper = as.double(exp(-exp(log(-log(fit.pred$survival)) - 1.96 * newse)))
+ )
         lower     upper
[1,] 0.6720145 0.9166403
[2,] 0.7317857 0.9473215
[3,] 0.8882076 0.9945995
[4,] 0.2325654 0.6310395
[5,] 0.3204751 0.7495790
[6,] 0.6477553 0.9717133
> 
> #### compute confidence intervals without transformation
> confint(fit.pred, survival.transform = "none")
   observation strata times survival survival.se survival.lower survival.upper
1:           1      0     3    0.830      0.0598          0.713          0.948
2:           2      0     3    0.878      0.0510          0.778          0.978
3:           3      0     3    0.975      0.0194          0.937          1.000
4:           1      0     8    0.441      0.1062          0.232          0.649
5:           2      0     8    0.564      0.1131          0.342          0.786
6:           3      0     8    0.894      0.0692          0.759          1.000
   survival.quantileBand survival.lowerBand survival.upperBand
1:                  2.24              0.697              0.964
2:                  2.20              0.766              0.991
3:                  2.10              0.934              1.000
4:                  2.24              0.203              0.678
5:                  2.20              0.315              0.813
6:                  2.10              0.749              1.000
> cbind(lower = as.double(fit.pred$survival - 1.96 * fit.pred$survival.se),
+       upper = as.double(fit.pred$survival + 1.96 * fit.pred$survival.se)
+ )
         lower     upper
[1,] 0.7130004 0.9475453
[2,] 0.7780635 0.9781347
[3,] 0.9368629 1.0130999
[4,] 0.2324617 0.6488784
[5,] 0.3422163 0.7857635
[6,] 0.7587567 1.0300007
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("getSplitMethod")
> ### * getSplitMethod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getSplitMethod
> ### Title: Input for data splitting algorithms
> ### Aliases: getSplitMethod
> 
> ### ** Examples
> 
> # 3-fold crossvalidation
> getSplitMethod("cv3",B=4,N=37)
$name
[1] "3-fold cross-validation"

$internal.name
[1] "crossval"

$index
      [,1] [,2] [,3] [,4]
 [1,]    1    2    3    2
 [2,]    1    3    3    2
 [3,]    1    1    1    1
 [4,]    2    3    2    3
 [5,]    2    1    3    1
 [6,]    3    3    1    2
 [7,]    3    2    2    3
 [8,]    1    2    1    2
 [9,]    3    1    1    1
[10,]    3    3    3    3
[11,]    1    1    2    2
[12,]    1    1    1    3
[13,]    1    3    2    2
[14,]    3    1    1    2
[15,]    2    1    2    1
[16,]    1    1    3    3
[17,]    3    2    2    3
[18,]    3    2    3    1
[19,]    2    3    1    3
[20,]    1    2    1    3
[21,]    3    3    3    1
[22,]    3    1    2    2
[23,]    1    2    1    2
[24,]    2    2    2    2
[25,]    2    1    3    1
[26,]    2    2    2    1
[27,]    2    3    2    3
[28,]    1    3    2    2
[29,]    3    1    3    1
[30,]    3    1    1    3
[31,]    2    2    3    1
[32,]    1    2    2    1
[33,]    1    3    3    3
[34,]    2    1    3    1
[35,]    2    3    1    3
[36,]    3    2    1    2
[37,]    2    3    1    1

$k
[1] 3

$B
[1] 4

$M
[1] 37

$N
[1] 37

attr(,"class")
[1] "split.method"
> 
> # bootstrap with replacement
> getSplitMethod("loob",B=4,N=37)
$name
[1] "LeaveOneOutBoot"

$internal.name
[1] "LeaveOneOutBoot"

$index
      [,1] [,2] [,3] [,4]
 [1,]    1    1    1    1
 [2,]    1    2    2    4
 [3,]    2    4    3    4
 [4,]    2    6    4    5
 [5,]    3    7    7    6
 [6,]    5    7    8    9
 [7,]    9    8    9    9
 [8,]    9    8   10   10
 [9,]   10    8   11   11
[10,]   11    9   12   13
[11,]   11   13   14   14
[12,]   12   14   14   16
[13,]   13   15   15   16
[14,]   14   16   15   17
[15,]   15   20   16   17
[16,]   15   21   17   19
[17,]   16   22   18   23
[18,]   16   24   20   23
[19,]   17   25   20   24
[20,]   17   26   22   25
[21,]   19   27   24   26
[22,]   19   27   25   26
[23,]   20   28   26   26
[24,]   24   28   27   26
[25,]   26   29   28   27
[26,]   28   29   28   28
[27,]   29   30   29   29
[28,]   31   31   29   30
[29,]   31   31   29   33
[30,]   32   35   31   33
[31,]   34   35   32   33
[32,]   34   36   33   34
[33,]   35   36   33   34
[34,]   35   36   34   35
[35,]   37   36   34   35
[36,]   37   37   37   37
[37,]   37   37   37   37

$k
NULL

$B
[1] 4

$M
[1] 37

$N
[1] 37

attr(,"class")
[1] "split.method"
> 
> # bootstrap without replacement
> getSplitMethod("loob",B=4,N=37,M=20)
$name
[1] "LeaveOneOutBoot"

$internal.name
[1] "LeaveOneOutBoot"

$index
      [,1] [,2] [,3] [,4]
 [1,]    1    4    1    1
 [2,]    3    5    2    2
 [3,]    4    7    6    4
 [4,]    5    9    7    5
 [5,]    8   12    8    8
 [6,]    9   15   13   10
 [7,]   10   17   14   12
 [8,]   11   18   15   13
 [9,]   12   19   17   15
[10,]   13   20   18   20
[11,]   19   22   21   23
[12,]   20   23   24   24
[13,]   21   25   25   25
[14,]   22   27   26   28
[15,]   25   31   27   31
[16,]   28   32   30   32
[17,]   30   34   31   33
[18,]   32   35   32   34
[19,]   34   36   36   35
[20,]   35   37   37   37

$k
NULL

$B
[1] 4

$M
[1] 20

$N
[1] 37

attr(,"class")
[1] "split.method"
> 
> 
> 
> 
> cleanEx()
> nameEx("iidCox")
> ### * iidCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: iidCox
> ### Title: Extract iid decomposition from a Cox model
> ### Aliases: iidCox iidCox.coxph iidCox.cph iidCox.phreg
> ###   iidCox.CauseSpecificCox
> 
> ### ** Examples
> 
> library(survival)
> library(data.table)
> library(prodlim)
> set.seed(10)
> d <- sampleData(100, outcome = "survival")[,.(eventtime,event,X1,X6)]
> setkey(d, eventtime)
> 
> m.cox <- coxph(Surv(eventtime, event) ~ X1+X6, data = d, y = TRUE, x = TRUE)
> system.time(IF.cox <- iidCox(m.cox))
   user  system elapsed 
  0.009   0.000   0.009 
> 
> IF.cox.all <- iidCox(m.cox, tau.hazard = sort(unique(c(7,d$eventtime))))
> IF.cox.beta <- iidCox(m.cox, baseline.iid = FALSE)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:data.table’, ‘package:survival’

> nameEx("influenceTest")
> ### * influenceTest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: influenceTest
> ### Title: Influence test [Experimental!!]
> ### Aliases: influenceTest influenceTest.list influenceTest.default
> 
> ### ** Examples
> 
> library(lava)
> library(survival)
> library(prodlim)
> library(data.table)
> n <- 100
> 
> #### Under H1
> set.seed(1)
> newdata <- data.frame(X1=0:1)
> 
> ## simulate non proportional hazard using lava
> m <- lvm()
> regression(m) <- y ~ 1
> regression(m) <- s ~ exp(-2*X1)
> distribution(m,~X1) <- binomial.lvm()
> distribution(m,~cens) <- coxWeibull.lvm(scale=1)
> distribution(m,~y) <- coxWeibull.lvm(scale=1,shape=~s)
> eventTime(m) <- eventtime ~ min(y=1,cens=0)
> d <- as.data.table(sim(m,n))
> setkey(d, eventtime)
> 
> ## fit cox models
> m.cox <- coxph(Surv(eventtime, status) ~ X1, 
+                data = d, y = TRUE, x = TRUE)
> 
> mStrata.cox <- coxph(Surv(eventtime, status) ~ strata(X1), 
+                      data = d, y = TRUE, x = TRUE)
> 
> ## compare models
> # one time point
> outIF <- influenceTest(list(m.cox, mStrata.cox), 
+               type = "survival", newdata = newdata, times = 0.5)
> confint(outIF)
        Comparison of two estimates of the survival at time 0.5

model 1:
coxph(formula = Surv(eventtime, status) ~ X1, data = d, x = TRUE, 
    y = TRUE)
model 2:
coxph(formula = Surv(eventtime, status) ~ strata(X1), data = d, 
    x = TRUE, y = TRUE)
   X1 time difference     se                               conf.interval
1:  0  0.5    -0.0608 0.0270 [-0.113699154852329 ; -0.00787307258824682]
2:  1  0.5     0.0361 0.0241  [-0.0111131003191009 ; 0.0833881342370634]
   p.value quantileBand                                   conf.band
1:  0.0243         1.98 [-0.114287064066313 ; -0.00728516337426317]
2:  0.1339         1.98  [-0.0115297713326029 ; 0.0838048052505654]
>                                  
> # several timepoints
> outIF <- influenceTest(list(m.cox, mStrata.cox), 
+               type = "survival", newdata = newdata, times = c(0.5,1,1.5))
> confint(outIF)
        Comparison of two estimates of the survival at time 0.5 1 1.5

model 1:
coxph(formula = Surv(eventtime, status) ~ X1, data = d, x = TRUE, 
    y = TRUE)
model 2:
coxph(formula = Surv(eventtime, status) ~ strata(X1), data = d, 
    x = TRUE, y = TRUE)
   X1 time difference     se                               conf.interval
1:  0  0.5    -0.0608 0.0270 [-0.113699154852329 ; -0.00787307258824682]
2:  0  1.0     0.0539 0.0273  [0.000441392312159838 ; 0.107274038619528]
3:  0  1.5     0.0539 0.0273  [0.000441392312159838 ; 0.107274038619528]
4:  1  0.5     0.0361 0.0241  [-0.0111131003191009 ; 0.0833881342370634]
5:  1  1.0    -0.0626 0.0234  [-0.108505628220617 ; -0.0166462684257652]
6:  1  1.5    -0.0626 0.0234  [-0.108505628220617 ; -0.0166462684257652]
   p.value quantileBand                                   conf.band
1: 0.02435         2.17 [-0.119384405269944 ; -0.00218782217063181]
2: 0.04814         2.17  [-0.00529793332514596 ; 0.113013364256834]
3: 0.04814         2.17  [-0.00529793332514596 ; 0.113013364256834]
4: 0.13388         2.17  [-0.0161942370503906 ; 0.0884692709683531]
5: 0.00758         2.17  [-0.113444716787645 ; -0.0117071798587372]
6: 0.00758         2.17  [-0.113444716787645 ; -0.0117071798587372]
> 
> #### Under H0 (Cox) ####
> set.seed(1)
> ## simulate proportional hazard using lava
> m <- lvm()
> regression(m) <- y ~ 1
> distribution(m,~X1) <- binomial.lvm()
> distribution(m,~cens) <- coxWeibull.lvm()
> distribution(m,~y) <- coxWeibull.lvm()
> eventTime(m) <- eventtime ~ min(y=1,cens=0)
> d <- as.data.table(sim(m,n))
> setkey(d, eventtime)
> 
> ## fit cox models
> Utime <- sort(unique(d$eventtime))
> m.cox <- coxph(Surv(eventtime, status) ~ X1, 
+                data = d, y = TRUE, x = TRUE)
> 
> mStrata.cox <- coxph(Surv(eventtime, status) ~ strata(X1), 
+                      data = d, y = TRUE, x = TRUE)
> 
> p.cox <- predictCox(m.cox, newdata = newdata, time = Utime, type = "survival")
> p.coxStrata <- predictCox(mStrata.cox, newdata = newdata, time = Utime, type = "survival")
> 
> ## display
> library(ggplot2)

Attaching package: ‘ggplot2’

The following object is masked from ‘package:lava’:

    vars

> autoplot(p.cox)
> autoplot(p.coxStrata)
>  
> ## compare models
> outIF <- influenceTest(list(m.cox, mStrata.cox), 
+                        type = "survival", newdata = newdata, times = Utime[1:6])
> confint(outIF)
        Comparison of two estimates of the survival at time 0.901 1.364 1.984 2.004 2.177 2.312

model 1:
coxph(formula = Surv(eventtime, status) ~ X1, data = d, x = TRUE, 
    y = TRUE)
model 2:
coxph(formula = Surv(eventtime, status) ~ strata(X1), data = d, 
    x = TRUE, y = TRUE)
    X1  time difference     se                              conf.interval
 1:  0 0.901    0.00000 0.0000                                    [0 ; 0]
 2:  0 1.364    0.01469 0.0140 [-0.0128137535186092 ; 0.0421837626207106]
 3:  0 1.984    0.00739 0.0155  [-0.0229445796653494 ; 0.037730343320489]
 4:  0 2.004    0.00739 0.0155  [-0.0229445796653494 ; 0.037730343320489]
 5:  0 2.177    0.02195 0.0200 [-0.0172488460712843 ; 0.0611415674028318]
 6:  0 2.312    0.03650 0.0232 [-0.0088844728314849 ; 0.0818841078787402]
 7:  1 0.901    0.00000 0.0000                                    [0 ; 0]
 8:  1 1.364   -0.01234 0.0120 [-0.0358307111708698 ; 0.0111453486007476]
 9:  1 1.984   -0.00627 0.0130 [-0.0317817818895643 ; 0.0192333171460028]
10:  1 2.004   -0.00627 0.0130 [-0.0317817818895643 ; 0.0192333171460028]
11:  1 2.177   -0.01871 0.0171 [-0.0521949568179435 ; 0.0147740545699256]
12:  1 2.312   -0.03108 0.0200 [-0.070209334620724 ; 0.00804722676630101]
    p.value quantileBand                                  conf.band
 1:      NA         2.34                                    [0 ; 0]
 2:   0.295         2.34 [-0.0180757420614204 ; 0.0474457511635218]
 3:   0.633         2.34 [-0.0287497645536752 ; 0.0435355282088148]
 4:   0.633         2.34 [-0.0287497645536752 ; 0.0435355282088148]
 5:   0.272         2.34 [-0.0247489931055997 ; 0.0686417144371471]
 6:   0.115         2.34 [-0.0175689237898613 ; 0.0905685588371165]
 7:      NA         2.34                                    [0 ; 0]
 8:   0.303         2.34   [-0.0404021458154122 ; 0.01571678324529]
 9:   0.630         2.34 [-0.0367462721482142 ; 0.0241978074046528]
10:   0.630         2.34 [-0.0367462721482142 ; 0.0241978074046528]
11:   0.273         2.34 [-0.0587119882645492 ; 0.0212910860165313]
12:   0.120         2.34 [-0.0778248042370913 ; 0.0156626963826683]
> 
> #### Under H0 (CSC) ####
> set.seed(1)
> ff <- ~ f(X1,2) + f(X2,-0.033)
> ff <- update(ff, ~ .+ f(X3,0) + f(X4,0) + f(X5,0))
> ff <- update(ff, ~ .+ f(X6,0) + f(X7,0) + f(X8,0) + f(X9,0))
> d <- sampleData(n, outcome = "competing.risk", formula = ff)
> d[,X1:=as.numeric(as.character(X1))]
> d[,X2:=as.numeric(as.character(X2))]
> d[,X3:=as.numeric(as.character(X3))]
> d[,X4:=as.numeric(as.character(X4))]
> d[,X5:=as.numeric(as.character(X5))]
> setkey(d, time)
> 
> Utime <- sort(unique(d$time))
> 
> ## fit cox models
> m.CSC <- CSC(Hist(time, event) ~ X1 + X2, data = d)
> mStrata.CSC <- CSC(Hist(time, event) ~ strata(X1) + X2 + X3, data = d)
> 
> ## compare models
> outIF <- influenceTest(list(m.CSC, mStrata.CSC), 
+              cause = 1, newdata = unique(d[,.(X1,X2,X3)]), times = Utime[1:5])
> confint(outIF)
        Comparison of two estimates of the absRisk at time 0.391 0.726 0.857 0.901 0.905

model 1:
CSC(formula = Hist(time, event) ~ X1 + X2, data = d)
model 2:
CSC(formula = Hist(time, event) ~ strata(X1) + X2 + X3, data = d)
    X1 X2  time difference      se                               conf.interval
 1:  0  0 0.391  -0.007397 0.00744   [-0.0219743786938676 ; 0.007181371548271]
 2:  0  0 0.726  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 3:  0  0 0.857  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 4:  0  0 0.901  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 5:  0  0 0.905  -0.002655 0.00817  [-0.0186698939924953 ; 0.0133604070247085]
 6:  1  0 0.391   0.050593 0.04990   [-0.0472082077990555 ; 0.148394996371111]
 7:  1  0 0.726   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
 8:  1  0 0.857   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
 9:  1  0 0.901   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
10:  1  0 0.905   0.006225 0.06230    [-0.115873609888316 ; 0.128323390542715]
11:  0  0 0.391  -0.005261 0.00553 [-0.0161037293343764 ; 0.00558179576256139]
12:  0  0 0.726  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
13:  0  0 0.857  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
14:  0  0 0.901  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
15:  0  0 0.905  -0.000519 0.00702   [-0.0142878452210002 ; 0.013249431826995]
16:  0  1 0.391  -0.007153 0.00745 [-0.0217639911955695 ; 0.00745730249264883]
17:  0  1 0.726  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
18:  0  1 0.857  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
19:  0  1 0.901  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
20:  0  1 0.905  -0.002897 0.00794   [-0.018450160664212 ; 0.0126555179617021]
21:  1  1 0.391   0.045388 0.04538   [-0.0435460500690034 ; 0.134322958157996]
22:  1  1 0.726   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
23:  1  1 0.857   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
24:  1  1 0.901   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
25:  1  1 0.905   0.017186 0.04965   [-0.0801261495409474 ; 0.114498317293765]
26:  0  1 0.391  -0.005146 0.00535 [-0.0156264718939994 ; 0.00533364739249466]
27:  0  1 0.726  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
28:  0  1 0.857  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
29:  0  1 0.901  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
30:  0  1 0.905  -0.000890 0.00664    [-0.013894957572693 ; 0.012114179071599]
31:  1  0 0.391   0.050593 0.04990   [-0.0472082077990555 ; 0.148394996371111]
32:  1  0 0.726   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
33:  1  0 0.857   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
34:  1  0 0.901   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
35:  1  0 0.905   0.022522 0.05427   [-0.0838491483671032 ; 0.128892887023336]
    X1 X2  time difference      se                               conf.interval
    p.value quantileBand                                   conf.band
 1:   0.320         2.14 [-0.0233028706160571 ; 0.00850986347046048]
 2:   0.745         2.14   [-0.020129365822692 ; 0.0148198788549053]
 3:   0.745         2.14   [-0.020129365822692 ; 0.0148198788549053]
 4:   0.745         2.14   [-0.020129365822692 ; 0.0148198788549053]
 5:   0.745         2.14   [-0.020129365822692 ; 0.0148198788549053]
 6:   0.311         2.20   [-0.0589422488110802 ; 0.160129037383135]
 7:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
 8:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
 9:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
10:   0.920         2.20    [-0.130522744242876 ; 0.142972524897274]
11:   0.342         2.15 [-0.0171743014576497 ; 0.00665236788583472]
12:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
13:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
14:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
15:   0.941         2.15  [-0.0156473069368985 ; 0.0146088935428933]
16:   0.337         2.14  [-0.023111000275824 ; 0.00880431157290333]
17:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
18:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
19:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
20:   0.715         2.14   [-0.019884033921284 ; 0.0140893912187741]
21:   0.317         2.14   [-0.0516932460308556 ; 0.142470154119848]
22:   0.729         2.14   [-0.0890408204331907 ; 0.123412988186009]
23:   0.729         2.14   [-0.0890408204331907 ; 0.123412988186009]
24:   0.729         2.14   [-0.0890408204331907 ; 0.123412988186009]
25:   0.729         2.14   [-0.0890408204331907 ; 0.123412988186009]
26:   0.336         2.15 [-0.0166329701571154 ; 0.00634014565561073]
27:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
28:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
29:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
30:   0.893         2.15  [-0.0151439080438144 ; 0.0133631295427205]
31:   0.311         2.14   [-0.0563341481430407 ; 0.157520936715096]
32:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
33:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
34:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
35:   0.678         2.14    [-0.0937747072651166 ; 0.13881844592135]
    p.value quantileBand                                   conf.band
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:data.table’, ‘package:prodlim’,
  ‘package:survival’, ‘package:lava’

> nameEx("ipcw")
> ### * ipcw
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ipcw
> ### Title: Estimation of censoring probabilities
> ### Aliases: ipcw ipcw.none ipcw.marginal ipcw.nonpar ipcw.cox ipcw.aalen
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: survival
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> dat=SimSurv(30)
> 
> dat <- dat[order(dat$time),]
> 
> # using the marginal Kaplan-Meier for the censoring times
> 
> WKM=ipcw(Hist(time,status)~X2,
+   data=dat,
+   method="marginal",
+   times=sort(unique(dat$time)),
+   subject.times=dat$time,keep=c("fit"))
> plot(WKM$fit)
> WKM$fit

Call: prodlim::prodlim(formula = formula, data = data, reverse = TRUE)

Kaplan-Meier estimator for the censoring time survival function

No covariates

Right-censored response of a survival model

No.Observations: 30 

Pattern:
                Freq
 event          19  
 right.censored 11  
> 
> # using the Cox model for the censoring times given X2
> library(survival)
> WCox=ipcw(Hist(time=time,event=status)~X2,
+   data=dat,
+   method="cox",
+   times=sort(unique(dat$time)),
+   subject.times=dat$time,keep=c("fit"))
> WCox$fit
Cox Proportional Hazards Model
 
 (function (formula = formula(data), data = environment(formula), 
     weights, subset, na.action = na.delete, method = c("efron", 
         "breslow", "exact", "model.frame", "model.matrix"), singular.ok = FALSE, 
     robust = FALSE, model = FALSE, x = FALSE, y = FALSE, se.fit = FALSE, 
     linear.predictors = TRUE, residuals = TRUE, nonames = FALSE, 
     eps = 1e-04, init, iter.max = 10, tol = 1e-09, surv = FALSE, 
     time.inc, type = NULL, vartype = NULL, debug = FALSE, ...) 
 {
     method <- match.arg(method)
     call <- match.call()
     if (!inherits(formula, "formula")) {
         if (inherits(formula, "Surv")) {
             xx <- function(x) formula(x)
             formula <- xx(paste(deparse(substitute(formula)), 
                 1, sep = "~"))
         }
         else stop("Invalid formula")
     }
     callenv <- parent.frame()
     weights <- if (!missing(weights)) 
         eval(substitute(weights), data, callenv)
     subset <- if (!missing(subset)) 
         eval(substitute(subset), data, callenv)
     data <- modelData(data, formula, weights = weights, subset = subset, 
         na.action = na.action, dotexpand = FALSE, callenv = callenv)
     nstrata <- 0
     Strata <- NULL
     odb <- .Options$debug
     if (length(odb) && is.logical(odb) && odb) 
         debug <- TRUE
     if (length(z <- attr(terms(formula, allowDotAsName = TRUE), 
         "term.labels")) > 0 && any(z != ".")) {
         X <- Design(data, formula, specials = c("strat", "strata"))
         atrx <- attributes(X)
         atr <- atrx$Design
         nact <- atrx$na.action
         sformula <- atrx$sformula
         mmcolnames <- atr$mmcolnames
         if (method == "model.frame") 
             return(X)
         Terms <- terms(sformula, specials = c("strat", "strata"), 
             data = data)
         asm <- atr$assume.code
         name <- atr$name
         specials <- attr(Terms, "specials")
         if (length(specials$strata)) 
             stop("cph supports strat(), not strata()")
         stra <- specials$strat
         cluster <- attr(X, "cluster")
         if (length(cluster)) {
             if (missing(robust)) 
                 robust <- TRUE
             attr(X, "cluster") <- NULL
         }
         Terms.ns <- Terms
         if (length(stra)) {
             temp <- untangle.specials(Terms.ns, "strat", 1)
             Terms.ns <- Terms.ns[-temp$terms]
             Strata <- list()
             strataname <- attr(Terms, "term.labels")[stra - 1]
             j <- 0
             for (i in (1:length(asm))[asm == 8]) {
                 nstrata <- nstrata + 1
                 xi <- X[[i + 1]]
                 levels(xi) <- paste(name[i], "=", levels(xi), 
                   sep = "")
                 Strata[[nstrata]] <- xi
             }
             Strata <- interaction(as.data.frame(Strata), drop = TRUE)
         }
         xpres <- length(asm) && any(asm != 8)
         Y <- model.extract(X, "response")
         if (!inherits(Y, "Surv")) 
             stop("response variable should be a Surv object")
         n <- nrow(Y)
         weights <- model.extract(X, "weights")
         offset <- attr(X, "offset")
         if (!xpres) {
             X <- matrix(nrow = 0, ncol = 0)
             assign <- NULL
         }
         else {
             X <- model.matrix(sformula, X)
             alt <- attr(mmcolnames, "alt")
             if (debug) {
                 print(cbind(`colnames(X)` = colnames(X)[-1], 
                   mmcolnames = mmcolnames, `Design colnames` = atr$colnames, 
                   alt = alt))
             }
             if (!all(mmcolnames %in% colnames(X)) && length(alt)) 
                 mmcolnames <- alt
             X <- X[, mmcolnames, drop = FALSE]
             assign <- attr(X, "assign")
             assign[[1]] <- NULL
         }
         nullmod <- FALSE
     }
     else {
         X <- NULL
         Y <- data[[1]]
         sformula <- formula
         mmcolnames <- ""
         weights <- if ("(weights)" %in% names(data)) 
             data[["(weights)"]]
         atr <- atrx <- NULL
         Terms <- terms(formula, allowDotAsName = TRUE)
         if (!inherits(Y, "Surv")) 
             stop("response variable should be a Surv object")
         Y <- Y[!is.na(Y)]
         assign <- NULL
         xpres <- FALSE
         nullmod <- TRUE
         nact <- NULL
     }
     ny <- ncol(Y)
     maxtime <- max(Y[, ny - 1])
     rnam <- if (!nonames) 
         dimnames(Y)[[1]]
     if (xpres) 
         dimnames(X) <- list(rnam, atr$colnames)
     if (method == "model.matrix") 
         return(X)
     time.units <- units(Y)
     if (!length(time.units) || time.units == "") 
         time.units <- "Day"
     if (missing(time.inc)) {
         time.inc <- switch(time.units, Day = 30, Month = 1, Year = 1, 
             maxtime/10)
         if (time.inc >= maxtime | maxtime/time.inc > 25) 
             time.inc <- max(pretty(c(0, maxtime)))/10
     }
     ytype <- attr(Y, "type")
     if (nullmod) 
         f <- NULL
     else {
         fitter <- if (method == "breslow" || method == "efron") {
             if (ytype == "right") 
                 coxph.fit
             else agreg.fit
         }
         else if (method == "exact") {
             if (ytype == "right") 
                 getFromNamespace("coxexact.fit", "survival")
             else agexact.fit
         }
         else stop(paste("Unknown method", method))
         if (missing(init)) 
             init <- NULL
         f <- fitter(X, Y, strata = Strata, offset = offset, weights = weights, 
             init = init, method = method, rownames = rnam, control = coxph.control(eps = eps, 
                 toler.chol = tol, toler.inf = 1, iter.max = iter.max))
     }
     if (is.character(f)) {
         cat("Failure in cph:\n", f, "\n")
         return(structure(list(fail = TRUE), class = "cph"))
     }
     else {
         if (length(f$coefficients) && any(is.na(f$coefficients))) {
             vars <- names(f$coefficients)[is.na(f$coefficients)]
             msg <- paste("X matrix deemed to be singular; variable", 
                 paste(vars, collapse = " "))
             if (singular.ok) 
                 warning(msg)
             else {
                 cat(msg, "\n")
                 return(structure(list(fail = TRUE), class = "cph"))
             }
         }
     }
     f$terms <- Terms
     f$sformula <- sformula
     f$mmcolnames <- mmcolnames
     if (robust) {
         f$naive.var <- f$var
         if (!length(cluster)) 
             cluster <- FALSE
         fit2 <- c(f, list(x = X, y = Y, weights = weights, method = method))
         if (length(stra)) 
             fit2$strata <- Strata
         r <- getS3method("residuals", "coxph")(fit2, type = "dfbeta", 
             collapse = cluster, weighted = TRUE)
         f$var <- t(r) %*% r
     }
     nvar <- length(f$coefficients)
     ev <- factor(Y[, ny], levels = 0:1, labels = c("No Event", 
         "Event"))
     n.table <- {
         if (!length(Strata)) 
             table(ev, dnn = "Status")
         else table(Strata, ev, dnn = c("Stratum", "Status"))
     }
     f$n <- n.table
     nevent <- sum(Y[, ny])
     if (xpres) {
         logtest <- -2 * (f$loglik[1] - f$loglik[2])
         R2.max <- 1 - exp(2 * f$loglik[1]/n)
         R2 <- (1 - exp(-logtest/n))/R2.max
         P <- 1 - pchisq(logtest, nvar)
         gindex <- GiniMd(f$linear.predictors)
         dxy <- dxy.cens(f$linear.predictors, Y, type = "hazard")["Dxy"]
         stats <- c(n, nevent, logtest, nvar, P, f$score, 1 - 
             pchisq(f$score, nvar), R2, dxy, gindex, exp(gindex))
         names(stats) <- c("Obs", "Events", "Model L.R.", "d.f.", 
             "P", "Score", "Score P", "R2", "Dxy", "g", "gr")
     }
     else {
         stats <- c(n, nevent)
         names(stats) <- c("Obs", "Events")
     }
     f$method <- NULL
     if (xpres) 
         dimnames(f$var) <- list(atr$colnames, atr$colnames)
     f <- c(f, list(call = call, Design = atr, assign = DesignAssign(atr, 
         0, atrx$terms), na.action = nact, fail = FALSE, non.slopes = 0, 
         stats = stats, method = method, maxtime = maxtime, time.inc = time.inc, 
         units = time.units))
     if (xpres) {
         f$center <- sum(f$means * f$coefficients)
         f$scale.pred <- c("log Relative Hazard", "Hazard Ratio")
         attr(f$linear.predictors, "strata") <- Strata
         names(f$linear.predictors) <- rnam
         if (se.fit) {
             XX <- X - rep(f$means, rep.int(n, nvar))
             se.fit <- drop(((XX %*% f$var) * XX) %*% rep(1, ncol(XX)))^0.5
             names(se.fit) <- rnam
             f$se.fit <- se.fit
         }
     }
     if (model) 
         f$model <- data
     if (is.character(surv) || surv) {
         if (length(Strata)) {
             iStrata <- as.character(Strata)
             slev <- levels(Strata)
             nstr <- length(slev)
         }
         else nstr <- 1
         srv <- NULL
         tim <- NULL
         s.e. <- NULL
         timepts <- seq(0, maxtime, by = time.inc)
         s.sum <- array(double(1), c(length(timepts), nstr, 3), 
             list(format(timepts), paste("Stratum", 1:nstr), c("Survival", 
                 "n.risk", "std.err")))
         g <- list(n = sum(f$n), coefficients = f$coefficients, 
             linear.predictors = f$linear.predictors, method = f$method, 
             type = type, means = f$means, var = f$var, x = X, 
             y = Y, strata = Strata, offset = offset, weights = weights, 
             terms = Terms, call = call)
         g <- survfit.cph(g, se.fit = is.character(surv) || surv, 
             type = type, vartype = vartype, conf.type = "log")
         strt <- if (nstr > 1) 
             rep(names(g$strata), g$strata)
         for (k in 1:nstr) {
             j <- if (nstr == 1) 
                 TRUE
             else strt == slev[k]
             yy <- Y[if (nstr == 1) 
                 TRUE
             else iStrata == slev[k], ny - 1]
             maxt <- max(yy)
             tt <- c(0, g$time[j])
             su <- c(1, g$surv[j])
             se <- c(NA, g$std.err[j])
             if (maxt > tt[length(tt)]) {
                 tt <- c(tt, maxt)
                 su <- c(su, su[length(su)])
                 se <- c(se, NA)
             }
             kk <- 0
             for (tp in timepts) {
                 kk <- kk + 1
                 t.choice <- max((1:length(tt))[tt <= tp + 1e-06])
                 if (tp > max(tt) + 1e-06 & su[length(su)] > 0) {
                   Su <- NA
                   Se <- NA
                 }
                 else {
                   Su <- su[t.choice]
                   Se <- se[t.choice]
                 }
                 n.risk <- sum(yy >= tp)
                 s.sum[kk, k, 1:3] <- c(Su, n.risk, Se)
             }
             if (!is.character(surv)) {
                 if (nstr == 1) {
                   tim <- tt
                   srv <- su
                   s.e. <- se
                 }
                 else {
                   tim <- c(tim, list(tt))
                   srv <- c(srv, list(su))
                   s.e. <- c(s.e., list(se))
                 }
             }
         }
         if (is.character(surv)) 
             f$surv.summary <- s.sum
         else {
             if (nstr > 1) {
                 names(srv) <- names(tim) <- names(s.e.) <- levels(Strata)
             }
             f <- c(f, list(time = tim, surv = srv, std.err = s.e., 
                 surv.summary = s.sum))
         }
     }
     f$strata <- Strata
     if (x) 
         f$x <- X
     if (y) 
         f$y <- Y
     f$weights <- weights
     f$offset <- offset
     if (!linear.predictors) 
         f$linear.predictors <- NULL
     if (!residuals) 
         f$residuals <- NULL
     class(f) <- c("cph", "rms", "coxph")
     f
 })(formula = Surv(time, status) ~ X2, data = structure(list(time = c(0.492967146723343, 
 0.751028491262217, 0.85690323555647, 1.55066740292543, 1.5529911630034, 
 2.49957953925262, 2.72813843472151, 2.92453672792375, 3.09566675772413, 
 3.4939918159165, 3.63430756589682, 3.71105077263798, 4.44729303005845, 
 4.57872508730397, 4.64955854779207, 4.75934018341804, 4.99979038448156, 
 5.0854691947226, 5.25787199056587, 5.78516506840998, 6.41999506940776, 
 6.65370629975601, 7.64347118490518, 7.99067276286092, 8.98219893552586, 
 9.15741788589595, 9.16814453632736, 10.152756975698, 11.2753806784844, 
 11.4384014642223), status = c(0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 
 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1), X2 = c(0.821221195098089, 
 -0.626453810742332, -2.2146998871775, 1.12493091814311, 0.918977371608218, 
 0.61982574789471, 0.329507771815361, 0.782136300731067, 0.417941560199702, 
 1.51178116845085, 1.59528080213779, 0.593901321217509, -0.0449336090152309, 
 0.575781351653492, -0.0161902630989461, -0.820468384118015, 0.943836210685299, 
 -0.305388387156356, 0.738324705129217, -0.155795506705329, 0.487429052428485, 
 -0.835628612410047, 0.183643324222082, 0.389843236411431, -0.47815005510862, 
 -0.0561287395290008, -1.98935169586337, 0.0745649833651906, -1.47075238389927, 
 -0.621240580541804)), row.names = c("19", "1", "14", "15", "21", 
 "25", "5", "22", "30", "11", "4", "20", "16", "9", "17", "6", 
 "18", "10", "8", "27", "7", "3", "2", "12", "29", "26", "24", 
 "23", "28", "13"), class = "data.frame"), x = TRUE, y = TRUE, 
     eps = 1e-06, surv = TRUE)
 
                        Model Tests    Discrimination    
                                              Indexes    
 Obs        30    LR chi2      0.02    R2       0.001    
 Events     11    d.f.            1    Dxy      0.085    
 Center 0.0048    Pr(> chi2) 0.8864    g        0.061    
                  Score chi2   0.02    gr       1.062    
                  Pr(> chi2) 0.8869                      
 
    Coef   S.E.   Wald Z Pr(>|Z|)
 X2 0.0586 0.4118 0.14   0.8869  
 
> 
> plot(WKM$fit)
> lines(sort(unique(dat$time)),
+       1-WCox$IPCW.times[1,],
+       type="l",
+       col=2,
+       lty=3,
+       lwd=3)
> lines(sort(unique(dat$time)),
+       1-WCox$IPCW.times[5,],
+       type="l",
+       col=3,
+       lty=3,
+       lwd=3)
> 
> # using the stratified Kaplan-Meier
> # for the censoring times given X2
> 
> WKM2=ipcw(Hist(time,status)~X2,
+   data=dat,
+   method="nonpar",
+   times=sort(unique(dat$time)),
+   subject.times=dat$time,keep=c("fit"))
> plot(WKM2$fit,add=FALSE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:rms’, ‘package:SparseM’, ‘package:Hmisc’,
  ‘package:ggplot2’, ‘package:Formula’, ‘package:survival’,
  ‘package:lattice’, ‘package:prodlim’

> nameEx("penalizedS3")
> ### * penalizedS3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: penalizedS3
> ### Title: S3-wrapper for S4 function penalized
> ### Aliases: penalizedS3
> 
> ### ** Examples
> 
> library(prodlim)
> ## Not run: 
> ##D ## too slow
> ##D if (requireNamespace("penalized",quietly=TRUE)){
> ##D library(penalized)
> ##D set.seed(8)
> ##D d <- sampleData(200,outcome="binary")
> ##D newd <- sampleData(80,outcome="binary")
> ##D fitridge <- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="ridge",
> ##D                 standardize=TRUE, model="logistic",trace=FALSE)
> ##D fitlasso <- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="lasso",
> ##D                 standardize=TRUE, model="logistic",trace=FALSE)
> ##D # fitnet <- penalizedS3(Y~X1+X2+pen(7:8), data=d, type="elastic.net",
> ##D # standardize=TRUE, model="logistic",trace=FALSE)
> ##D predictRisk(fitridge,newdata=newd)
> ##D predictRisk(fitlasso,newdata=newd)
> ##D # predictRisk(fitnet,newdata=newd)
> ##D Score(list(fitridge),data=newd,formula=Y~1)
> ##D Score(list(fitridge),data=newd,formula=Y~1,split.method="bootcv",B=2)
> ##D data(nki70) ## S4 fit
> ##D fitS4 <- penalized(Surv(time, event), penalized = nki70[,8:77],
> ##D                  unpenalized = ~ER+Age+Diam+N+Grade, data = nki70,
> ##D                  lambda1 = 1)
> ##D fitS3 <- penalizedS3(Surv(time,event)~ER+Age+Diam+pen(8:77)+N+Grade,
> ##D                      data=nki70, lambda1=1)
> ##D ## or
> ##D penS3 <- penalizedS3(Surv(time,event)~ER+pen(TSPYL5,Contig63649_RC)+pen(10:77)+N+Grade,
> ##D                      data=nki70, lambda1=1)
> ##D ## also this works
> ##D penS3 <- penalizedS3(Surv(time,event)~ER+Age+pen(8:33)+Diam+pen(34:77)+N+Grade,
> ##D                     data=nki70, lambda1=1)
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’

> nameEx("plot.riskRegression")
> ### * plot.riskRegression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.riskRegression
> ### Title: Plotting predicted risk
> ### Aliases: plot.riskRegression
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(survival)
> library(prodlim)
> data(Melanoma)
> fit.arr <- ARR(Hist(time,status)~invasion+age+strata(sex),data=Melanoma,cause=1)
> plot(fit.arr,xlim=c(500,3000))
Warning in plot.riskRegression(fit.arr, xlim = c(500, 3000)) :
  Argument newdata is missing.
Shown are the cumulative incidence curves from the original data set.
Selected are curves based on individual risk (min,q25,median,q75,max) at the median time:1112.25714285714
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotAUC")
> ### * plotAUC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotAUC
> ### Title: Plot of time-dependent AUC curves
> ### Aliases: plotAUC
> 
> ### ** Examples
> 
> library(survival)
> library(prodlim)
> d=sampleData(100,outcome="survival")
> nd=sampleData(100,outcome="survival")
> f1=coxph(Surv(time,event)~X1+X6+X8,data=d,x=TRUE,y=TRUE)
> f2=coxph(Surv(time,event)~X2+X5+X9,data=d,x=TRUE,y=TRUE)
> xx=Score(list("X1+X6+X8"=f1,"X2+X5+X9"=f2), formula=Surv(time,event)~1,
+ data=nd, metrics="auc", null.model=FALSE, times=seq(3:10))
> aucgraph <- plotAUC(xx)
> plotAUC(xx,conf.int=TRUE)
> ## difference between 
> plotAUC(xx,which="contrasts",conf.int=TRUE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotBrier")
> ### * plotBrier
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotBrier
> ### Title: Plot Brier curve
> ### Aliases: plotBrier
> 
> ### ** Examples
> 
> # survival
> library(survival)
> library(prodlim)
> ds1=sampleData(40,outcome="survival")
> ds2=sampleData(40,outcome="survival")
> f1 <- coxph(Surv(time,event)~X1+X3+X5+X7+X9,data=ds1,x=TRUE)
> f2 <- coxph(Surv(time,event)~X2+X4+X6+X8+X10,data=ds1,x=TRUE)
> xscore <- Score(list(f1,f2),formula=Hist(time,event)~1,data=ds2,times=0:12,metrics="brier")
> plotBrier(xscore)
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotCalibration")
> ### * plotCalibration
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotCalibration
> ### Title: Plot Calibration curve
> ### Aliases: plotCalibration
> 
> ### ** Examples
> 
> library(prodlim)
> # binary 
> db=sampleData(100,outcome="binary")
> fb1=glm(Y~X1+X5+X7,data=db,family="binomial")
> fb2=glm(Y~X1+X3+X6+X7,data=db,family="binomial")
> xb=Score(list(model1=fb1,model2=fb2),Y~1,data=db,
+           plots="cal")
> plotCalibration(xb,brier.in.legend=TRUE)
> plotCalibration(xb,bars=TRUE,model="model1")
> plotCalibration(xb,models=1,bars=TRUE,names.cex=1.3)
> 
> # survival
> library(survival)
> library(prodlim)
> dslearn=sampleData(56,outcome="survival")
> dstest=sampleData(100,outcome="survival")
> fs1=coxph(Surv(time,event)~X1+X5+X7,data=dslearn,x=1)
> fs2=coxph(Surv(time,event)~strata(X1)+X3+X6+X7,data=dslearn,x=1)
> xs=Score(list(Cox1=fs1,Cox2=fs2),Surv(time,event)~1,data=dstest,
+           plots="cal",metrics=NULL)
> plotCalibration(xs)
The default method for estimating calibration curves based on censored data has changed for riskRegression version 2019-9-8 or higher
Set cens.method="jackknife" to get the estimate using pseudo-values.
However, note that the option "jackknife" is sensititve to violations of the assumption that the censoring is independent of both the event times and the covariates.
Set cens.method="local" to suppress this message.
> plotCalibration(xs,cens.method="local",pseudo=1)
> plotCalibration(xs,method="quantile")
The default method for estimating calibration curves based on censored data has changed for riskRegression version 2019-9-8 or higher
Set cens.method="jackknife" to get the estimate using pseudo-values.
However, note that the option "jackknife" is sensititve to violations of the assumption that the censoring is independent of both the event times and the covariates.
Set cens.method="local" to suppress this message.
> 
> 
> # competing risks
> 
> ## Not run: 
> ##D data(Melanoma)
> ##D f1 <- CSC(Hist(time,status)~age+sex+epicel+ulcer,data=Melanoma)
> ##D f2 <- CSC(Hist(time,status)~age+sex+logthick+epicel+ulcer,data=Melanoma)
> ##D x <- Score(list(model1=f1,model2=f2),Hist(time,status)~1,data=Melanoma,
> ##D            cause= 2,times=5*365.25,plots="cal")
> ##D plotCalibration(x)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("plotEffects")
> ### * plotEffects
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotEffects
> ### Title: Plotting time-varying effects from a risk regression model.
> ### Aliases: plotEffects
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(survival)
> library(prodlim)
> data(Melanoma)
> 
> fit.tarr <- ARR(Hist(time,status)~strata(sex),
+                 data=Melanoma,
+                 cause=1)
> plotEffects(fit.tarr)
> 
> fit.tarr <- ARR(Hist(time,status)~strata(sex)+strata(invasion),
+                 data=Melanoma,
+                 cause=1,
+                 times=seq(800,3000,20))
> plotEffects(fit.tarr,formula=~sex)
> plotEffects(fit.tarr,formula=~invasion)
> plotEffects(fit.tarr,
+             formula=~invasion,
+             level="invasionlevel.1")
> 
> ## legend arguments are transcluded:
> plotEffects(fit.tarr,
+             formula=~invasion,
+             legend.bty="b",
+             legend.cex=1)
> 
> ## and other smart arguments too:
> plotEffects(fit.tarr,
+ 	    formula=~invasion,
+ 	    legend.bty="b",
+ axis2.las=2,
+ 	    legend.cex=1)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("plotPredictRisk")
> ### * plotPredictRisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotPredictRisk
> ### Title: Plotting predicted risks curves.
> ### Aliases: plotPredictRisk
> ### Keywords: survival
> 
> ### ** Examples
> 
> library(survival)
> # generate survival data
> # no effect
> set.seed(8)
> d <- sampleData(80,outcome="survival",formula = ~f(X6, 0) + f(X7, 0))
> d[,table(event)]
event
 0  1 
40 40 
> f <- coxph(Surv(time,event)~X6+X7,data=d,x=1)
> plotPredictRisk(f)
> 
> # large effect
> set.seed(8)
> d <- sampleData(80,outcome="survival",formula = ~f(X6, 0.1) + f(X7, -0.1))
> d[,table(event)]
event
 0  1 
41 39 
> f <- coxph(Surv(time,event)~X6+X7,data=d,x=1)
> plotPredictRisk(f)
> 
> # generate competing risk data
> # small effect
> set.seed(8)
> d <- sampleData(40,formula = ~f(X6, 0.01) + f(X7, -0.01))
> d[,table(event)]
event
 0  1  2 
11 16 13 
> f <- CSC(Hist(time,event)~X5+X6,data=d)
> plotPredictRisk(f)
> 
> # large effect
> set.seed(8)
> d <- sampleData(40,formula = ~f(X6, 0.1) + f(X7, -0.1))
> d[,table(event)]
event
 0  1  2 
 7 21 12 
> f <- CSC(Hist(time,event)~X5+X6,data=d)
> plotPredictRisk(f)
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("plotROC")
> ### * plotROC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotROC
> ### Title: Plot ROC curves
> ### Aliases: plotROC
> 
> ### ** Examples
> 
> ## binary
> set.seed(18)
> if (requireNamespace("randomForest",quietly=TRUE)){
+ library(randomForest)
+ library(prodlim)
+ bdl <- sampleData(40,outcome="binary")
+ bdt <- sampleData(58,outcome="binary")
+ bdl[,y:=factor(Y)]
+ bdt[,y:=factor(Y)]
+ fb1 <- glm(y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=bdl,family="binomial")
+ fb2 <- randomForest(y~X1+X2+X3+X4+X5+X6+X7+X8+X9+X10,data=bdl)
+ xb <- Score(list("glm"=fb1,"rf"=fb2),y~1,data=bdt,
+             plots="roc",metrics=c("auc","brier"))
+ plotROC(xb,brier.in.legend=1L)
+ 
+ # with cross-validation
+ ## Not run: 
+ ##D xb3 <- Score(list("glm"=fb1,"rf"=fb2),y~1,data=bdl,
+ ##D             plots="roc",B=3,split.method="bootcv",
+ ##D             metrics=c("auc"))
+ ## End(Not run)
+ }
randomForest 4.6-14
Type rfNews() to see new features/changes/bug fixes.
> ## survival
> set.seed(18)
> library(survival)
> sdl <- sampleData(40,outcome="survival")
> sdt <- sampleData(58,outcome="survival")
> fs1 <- coxph(Surv(time,event)~X3+X5+X6+X7+X8+X10,data=sdl,x=TRUE)
> fs2 <- coxph(Surv(time,event)~X1+X2+X9,data=sdl,x=TRUE)
> xs <- Score(list(model1=fs1,model2=fs2),Hist(time,event)~1,data=sdt,
+             times=5,plots="roc",metrics="auc")
> plotROC(xs)
> ## competing risks
> data(Melanoma)
> f1 <- CSC(Hist(time,status)~age+sex+epicel+ulcer,data=Melanoma)
> f2 <- CSC(Hist(time,status)~age+sex+logthick+epicel+ulcer,data=Melanoma)
> x <- Score(list(model1=f1,model2=f2),Hist(time,status)~1,data=Melanoma,
+             cause=1,times=5*365.25,plots="roc",metrics="auc")
> plotROC(x)
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’, ‘package:randomForest’

> nameEx("plotRisk")
> ### * plotRisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotRisk
> ### Title: plot predicted risks
> ### Aliases: plotRisk
> 
> ### ** Examples
> 
> library(prodlim)
> ## uncensored
> learndat = sampleData(40,outcome="binary")
> testdat = sampleData(40,outcome="binary")
> lr1 = glm(Y~X1+X2+X7+X9,data=learndat,family="binomial")
> lr2 = glm(Y~X3+X5+X6,data=learndat,family="binomial")
> xb=Score(list("LR(X1+X2+X7+X9)"=lr1,"LR(X3+X5+X6)"=lr2),formula=Y~1,
+          data=testdat,summary="risks",null.model=0L)
> plotRisk(xb)
> ## survival
> library(survival)
> learndat = sampleData(40,outcome="survival")
> testdat = sampleData(40,outcome="survival")
> cox1 = coxph(Surv(time,event)~X1+X2+X7+X9,data=learndat,x=TRUE)
> cox2 = coxph(Surv(time,event)~X3+X5+X6,data=learndat,x=TRUE)
> xs=Score(list("Cox(X1+X2+X7+X9)"=cox1,"Cox(X3+X5+X6)"=cox2),formula=Surv(time,event)~1,
+          data=testdat,summary="risks",null.model=0L,times=c(3,5,6))
> plotRisk(xs,times=5)
> ## competing risk
> ## Not run: 
> ##D library(prodlim)
> ##D library(survival)
> ##D set.seed(8)
> ##D learndat = sampleData(80,outcome="competing.risk")
> ##D testdat = sampleData(140,outcome="competing.risk")
> ##D m1 = FGR(Hist(time,event)~X2+X7+X9,data=learndat,cause=1)
> ##D m2 = CSC(Hist(time,event)~X2+X7+X9,data=learndat,cause=1)
> ##D xcr=Score(list("FGR"=m1,"CSC"=m2),formula=Hist(time,event)~1,
> ##D          data=testdat,summary="risks",null.model=0L,times=c(3,5))
> ##D plotRisk(xcr,times=1)
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("predict.CauseSpecificCox")
> ### * predict.CauseSpecificCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.CauseSpecificCox
> ### Title: Predicting Absolute Risk from Cause-Specific Cox Models
> ### Aliases: predict.CauseSpecificCox predictBig.CauseSpecificCox
> 
> ### ** Examples
> 
> library(survival)
> library(prodlim)
> #### generate data ####
> set.seed(5)
> d <- sampleData(80,outcome="comp") ## training dataset
> nd <- sampleData(4,outcome="comp") ## validation dataset
> d$time <- round(d$time,1) ## create tied events
> ttt <- sort(sample(x = unique(d$time), size = 10))
> 
> ## estimate a CSC model based on the coxph function
> CSC.fit <- CSC(Hist(time,event)~ X3+X8, data=d, method = "breslow")
> 
> ## compute the absolute risk of cause 1, in the validation dataset
> ## at time 1:10
> CSC.risk <-  predict(CSC.fit, newdata=nd, times=1:10, cause=1)
> CSC.risk
    observation X3      X8 times absRisk
 1:           1  1 -1.5612     1  0.0969
 2:           2  1 -0.7577     1  0.0948
 3:           3  0  1.5421     1  0.0810
 4:           4  0 -0.0647     1  0.0847
 5:           1  1 -1.5612     2  0.2667
 6:           2  1 -0.7577     2  0.2617
 7:           3  0  1.5421     2  0.2270
 8:           4  0 -0.0647     2  0.2359
 9:           1  1 -1.5612     3  0.3574
10:           2  1 -0.7577     3  0.3520
11:           3  0  1.5421     3  0.3085
12:           4  0 -0.0647     3  0.3186
13:           1  1 -1.5612     4  0.4220
14:           2  1 -0.7577     4  0.4172
15:           3  0  1.5421     4  0.3689
16:           4  0 -0.0647     4  0.3784
17:           1  1 -1.5612     5  0.4572
18:           2  1 -0.7577     5  0.4535
19:           3  0  1.5421     5  0.4036
20:           4  0 -0.0647     5  0.4113
21:           1  1 -1.5612     6  0.4765
22:           2  1 -0.7577     6  0.4738
23:           3  0  1.5421     6  0.4235
24:           4  0 -0.0647     6  0.4295
25:           1  1 -1.5612     7  0.5401
26:           2  1 -0.7577     7  0.5428
27:           3  0  1.5421     7  0.4934
28:           4  0 -0.0647     7  0.4903
29:           1  1 -1.5612     8  0.5625
30:           2  1 -0.7577     8  0.5671
31:           3  0  1.5421     8  0.5185
32:           4  0 -0.0647     8  0.5120
33:           1  1 -1.5612     9  0.5625
34:           2  1 -0.7577     9  0.5671
35:           3  0  1.5421     9  0.5185
36:           4  0 -0.0647     9  0.5120
37:           1  1 -1.5612    10  0.5967
38:           2  1 -0.7577    10  0.6073
39:           3  0  1.5421    10  0.5629
40:           4  0 -0.0647    10  0.5456
    observation X3      X8 times absRisk
> 
> ## compute absolute risks with CI for cause 2
> ## (without displaying the value of the covariates)
> predict(CSC.fit,newdata=nd,times=1:10,cause=2,se=TRUE,
+         keep.newdata = FALSE)
    observation times absRisk absRisk.se absRisk.lower absRisk.upper
 1:           1     1 0.00000     0.0000      0.000000        0.0000
 2:           2     1 0.00000     0.0000      0.000000        0.0000
 3:           3     1 0.00000     0.0000      0.000000        0.0000
 4:           4     1 0.00000     0.0000      0.000000        0.0000
 5:           1     2 0.01409     0.0155      0.000855        0.0764
 6:           2     2 0.01107     0.0113      0.000904        0.0554
 7:           3     2 0.00907     0.0111      0.000397        0.0593
 8:           4     2 0.01470     0.0153      0.001073        0.0739
 9:           1     3 0.06024     0.0455      0.008579        0.1904
10:           2     3 0.04785     0.0258      0.013482        0.1170
11:           3     3 0.04038     0.0297      0.006543        0.1290
12:           4     3 0.06422     0.0379      0.015235        0.1651
13:           1     4 0.06024     0.0455      0.008579        0.1904
14:           2     4 0.04785     0.0258      0.013482        0.1170
15:           3     4 0.04038     0.0297      0.006543        0.1290
16:           4     4 0.06422     0.0379      0.015235        0.1651
17:           1     5 0.14687     0.0920      0.026324        0.3636
18:           2     5 0.11898     0.0639      0.030524        0.2729
19:           3     5 0.10403     0.0816      0.011531        0.3174
20:           4     5 0.15961     0.0563      0.068873        0.2841
21:           1     6 0.18485     0.1198      0.027826        0.4513
22:           2     6 0.15128     0.0838      0.034903        0.3454
23:           3     6 0.13399     0.0953      0.017909        0.3663
24:           4     6 0.20173     0.0599      0.100005        0.3286
25:           1     7 0.18485     0.1198      0.027826        0.4513
26:           2     7 0.15128     0.0838      0.034903        0.3454
27:           3     7 0.13399     0.0953      0.017909        0.3663
28:           4     7 0.20173     0.0599      0.100005        0.3286
29:           1     8 0.20546     0.1285      0.032271        0.4822
30:           2     8 0.16927     0.0915      0.039727        0.3760
31:           3     8 0.15172     0.1087      0.018870        0.4083
32:           4     8 0.22556     0.0641      0.114794        0.3590
33:           1     9 0.25516     0.1524      0.040038        0.5600
34:           2     9 0.21404     0.1110      0.050731        0.4506
35:           3     9 0.19687     0.1332      0.025363        0.4873
36:           4     9 0.28284     0.0732      0.151571        0.4294
37:           1    10 0.25516     0.1524      0.040038        0.5600
38:           2    10 0.21404     0.1110      0.050731        0.4506
39:           3    10 0.19687     0.1332      0.025363        0.4873
40:           4    10 0.28284     0.0732      0.151571        0.4294
    observation times absRisk absRisk.se absRisk.lower absRisk.upper
> 
> ## other example
> library(survival)
> CSC.fit.s <- CSC(list(Hist(time,event)~ strata(X1)+X2+X9,
+  Hist(time,event)~ X2+strata(X4)+X8+X7),data=d, method = "breslow")
> predict(CSC.fit.s,cause=1,times=ttt,se=1L) ## note: absRisk>1 due to small number of observations
     observation X2     X9       X8   X7 times    strata absRisk absRisk.se
  1:           1  0 -0.836 -0.39410 57.5   0.6 X1=0 X4=1  0.0871     0.0417
  2:           2  0  2.030 -1.51024 56.2   0.6 X1=0 X4=0  0.0170     0.0102
  3:           3  0  0.429  0.00599 77.0   0.6 X1=0 X4=1  0.0426     0.0202
  4:           4  0  1.064  0.85501 57.7   0.6 X1=0 X4=1  0.0297     0.0151
  5:           5  1 -0.606  0.72985 68.6   0.6 X1=0 X4=0  0.1319     0.0577
 ---                                                                       
796:          76  0  0.477  0.36861 63.9  11.8 X1=0 X4=0  0.4500     0.0877
797:          77  0  1.308  0.64851 58.3  11.8 X1=0 X4=0  0.3206     0.0853
798:          78  0  1.806 -0.43983 59.9  11.8 X1=0 X4=0  0.2397     0.0794
799:          79  1  1.035 -0.86642 59.3  11.8 X1=0 X4=0  0.4509     0.1609
800:          80  0  0.517  0.86530 59.7  11.8 X1=1 X4=0      NA     0.1457
     absRisk.lower absRisk.upper
  1:       0.02773        0.1899
  2:       0.00441        0.0470
  3:       0.01445        0.0954
  4:       0.00939        0.0706
  5:       0.04538        0.2654
 ---                            
796:       0.27569        0.6096
797:       0.16536        0.4872
798:       0.10535        0.4039
799:       0.14713        0.7182
800:            NA            NA
> 
> ## using the cph function instead of coxph
> CSC.cph <- CSC(Hist(time,event)~ X1+X2,data=d, method = "breslow", fitter = "cph")#'
> predict(CSC.cph, newdata = d, cause = 2, times = ttt)
     observation X1 X2 times absRisk
  1:           1  0  0   0.6   0.000
  2:           2  0  0   0.6   0.000
  3:           3  0  0   0.6   0.000
  4:           4  0  0   0.6   0.000
  5:           5  0  1   0.6   0.000
 ---                                
796:          76  0  0  11.8   0.499
797:          77  0  0  11.8   0.499
798:          78  0  0  11.8   0.499
799:          79  0  1  11.8   0.340
800:          80  1  0  11.8   0.242
> 
> ## landmark analysis
> T0 <- 1
> predCSC.afterT0 <- predict(CSC.fit, newdata = d, cause = 2, times = ttt[ttt>T0], landmark = T0)
> predCSC.afterT0
     observation X3       X8 times absRisk
  1:           1  0 -0.39410   2.9  0.0761
  2:           2  1 -1.51024   2.9  0.0647
  3:           3  1  0.00599   2.9  0.0417
  4:           4  0  0.85501   2.9  0.0530
  5:           5  0  0.72985   2.9  0.0550
 ---                                      
636:          76  1  0.36861  11.8  0.3184
637:          77  0  0.64851  11.8  0.4514
638:          78  1 -0.43983  11.8  0.3727
639:          79  1 -0.86642  11.8  0.4022
640:          80  0  0.86530  11.8  0.4346
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:survival’

> nameEx("predict.FGR")
> ### * predict.FGR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.FGR
> ### Title: Predict subject specific risks (cumulative incidence) based on
> ###   Fine-Gray regression model
> ### Aliases: predict.FGR
> 
> ### ** Examples
> 
> library(prodlim)
> library(survival)
> set.seed(10)
> d <- sampleData(101, outcome = "competing.risk")
> tFun<-function(t) {t}
> fgr<-FGR(Hist(time, event)~X1+strata(X2)+X6+cov2(X7, tf=tFun),
+          data=d, cause=1)
> predictRisk(fgr,times=5,newdata=d[1:10])
            [,1]
 [1,] 0.13299138
 [2,] 0.85169265
 [3,] 0.42770067
 [4,] 0.38976643
 [5,] 0.11350808
 [6,] 0.04557124
 [7,] 0.16149427
 [8,] 0.13046172
 [9,] 0.10263051
[10,] 0.20155413
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("predict.riskRegression")
> ### * predict.riskRegression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predict.riskRegression
> ### Title: Predict individual risk.
> ### Aliases: predict.riskRegression
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> data(Melanoma)
> library(prodlim)
> library(survival)
> 
> fit.tarr <- ARR(Hist(time,status)~age+invasion+strata(sex),data=Melanoma,cause=1)
> predict(fit.tarr,newdata=data.frame(age=48,
+                      invasion=factor("level.1",
+                          levels=levels(Melanoma$invasion)),
+                      sex=factor("Female",levels=levels(Melanoma$sex))))
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> predict(fit.tarr,newdata=data.frame(age=48,
+                      invasion=factor("level.1",
+                          levels=levels(Melanoma$invasion)),
+                      sex=factor("Male",levels=levels(Melanoma$sex))))
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> predict(fit.tarr,newdata=data.frame(age=c(48,58,68),
+                      invasion=factor("level.1",
+                          levels=levels(Melanoma$invasion)),
+                      sex=factor("Male",levels=levels(Melanoma$sex))))
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
2    1    1    1    1    1    1    1    1    1     1     1     1     1     1
3    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> predict(fit.tarr,newdata=Melanoma[1:4,])
$time
 [1]  227.6000  273.6286  294.5429  388.2857  432.1429  482.7143  557.9143
 [8]  624.2000  643.5714  663.5714  700.5143  743.2571  774.3714  791.8000
[15]  817.0000  835.1429  859.8857  869.7714  904.5714  971.2857  979.5714
[22] 1017.4000 1050.6000 1060.4000 1073.1429 1151.3714 1228.6857 1254.1714
[29] 1279.2000 1347.1429 1461.3714 1510.5714 1533.3714 1555.5429 1577.1429
[36] 1613.6000 1661.7429 1689.3429 1737.8286 1951.2857 2061.2286 2074.8857
[43] 2105.0000 2179.8857 2331.4286 2439.9143 2539.8000 2744.8000 3019.7143
[50] 3338.0000

$risk
  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
1    1    1    1    1    1    1    1    1    1     1     1     1     1     1
2    1    1    1    1    1    1    1    1    1     1     1     1     1     1
3    1    1    1    1    1    1    1    1    1     1     1     1     1     1
4    1    1    1    1    1    1    1    1    1     1     1     1     1     1
  [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
4     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] [,39] [,40]
1     1     1     1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1     1     1     1
4     1     1     1     1     1     1     1     1     1     1     1     1     1
  [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
1     1     1     1     1     1     1     1     1     1     1
2     1     1     1     1     1     1     1     1     1     1
3     1     1     1     1     1     1     1     1     1     1
4     1     1     1     1     1     1     1     1     1     1

attr(,"class")
[1] "predictedRisk"
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("predictCox")
> ### * predictCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictCox
> ### Title: Fast computation of survival probabilities, hazards and
> ###   cumulative hazards from Cox regression models
> ### Aliases: predictCox
> 
> ### ** Examples
> 
> 
> library(survival)
> library(data.table)
> 
> #### generate data ####
> set.seed(10)
> d <- sampleData(40,outcome="survival") ## training dataset
> nd <- sampleData(4,outcome="survival") ## validation dataset
> d$time <- round(d$time,1) ## create tied events
> # table(duplicated(d$time))
> 
> #### stratified Cox model ####
> fit <- coxph(Surv(time,event)~X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## compute the baseline cumulative hazard
> fit.haz <- predictCox(fit)
> cbind(survival::basehaz(fit), fit.haz$cumhazard)
       hazard time strata fit.haz$cumhazard
1  0.02931158  1.0      0        0.02931158
2  0.04963195  1.8      0        0.04963195
3  0.07065434  2.1      0        0.07065434
4  0.11538240  2.2      0        0.11538240
5  0.13943016  2.5      0        0.13943016
6  0.16963629  2.7      0        0.16963629
7  0.20147775  3.0      0        0.20147775
8  0.20147775  3.2      0        0.20147775
9  0.23924231  3.5      0        0.23924231
10 0.27812921  3.6      0        0.27812921
11 0.32260585  3.7      0        0.32260585
12 0.36980891  4.0      0        0.36980891
13 0.42720764  4.7      0        0.42720764
14 0.42720764  5.1      0        0.42720764
15 0.48812085  5.5      0        0.48812085
16 0.55144168  5.8      0        0.55144168
17 0.62045178  5.9      0        0.62045178
18 0.70101250  6.6      0        0.70101250
19 0.78237932  6.9      0        0.78237932
20 0.78237932  7.0      0        0.78237932
21 0.78237932  7.2      0        0.78237932
22 0.89566220  7.7      0        0.89566220
23 1.08069860  8.4      0        1.08069860
24 1.08069860  9.2      0        1.08069860
25 1.08069860  9.5      0        1.08069860
26 1.08069860  9.6      0        1.08069860
27 1.98002958 11.0      0        1.98002958
28 4.15079877 11.1      0        4.15079877
29 4.15079877 11.5      0        4.15079877
30 9.27508322 12.0      0        9.27508322
31 0.03557926  0.6      1        0.03557926
32 0.16095498  3.6      1        0.16095498
33 0.16095498  4.2      1        0.16095498
34 0.85676310  4.7      1        0.85676310
35 3.07879773  7.5      1        3.07879773
> 
> ## compute individual specific cumulative hazard and survival probabilities 
> fit.pred <- predictCox(fit, newdata=nd, times=c(3,8), se = TRUE, band = TRUE)
> fit.pred
   observation strata times cumhazard cumhazard.se cumhazard.lower
1:           1      1     3    0.3728       0.1390          0.1795
2:           2      0     3    0.0677       0.0382          0.0224
3:           3      0     3    0.1181       0.0541          0.0482
4:           4      0     3    0.2030       0.0750          0.0985
5:           1      1     8        NA           NA              NA
6:           2      0     8    0.3008       0.1401          0.1207
7:           3      0     8    0.5251       0.1885          0.2598
8:           4      0     8    0.9026       0.2504          0.5240
   cumhazard.upper cumhazard.quantileBand cumhazard.lowerBand
1:           0.774                   1.96              0.1797
2:           0.205                   2.14              0.0202
3:           0.290                   2.17              0.0438
4:           0.419                   2.20              0.0900
5:              NA                   1.96                  NA
6:           0.749                   2.14              0.1110
7:           1.061                   2.17              0.2412
8:           1.555                   2.20              0.4899
   cumhazard.upperBand survival survival.se survival.lower survival.upper
1:               0.773    0.689      0.0957          0.461          0.836
2:               0.227    0.935      0.0357          0.815          0.978
3:               0.318    0.889      0.0480          0.749          0.953
4:               0.458    0.816      0.0612          0.658          0.906
5:                  NA       NA          NA             NA             NA
6:               0.815    0.740      0.1037          0.473          0.886
7:               1.143    0.592      0.1115          0.346          0.771
8:               1.663    0.406      0.1016          0.211          0.592
   survival.quantileBand survival.lowerBand survival.upperBand
1:                  1.99              0.457              0.837
2:                  2.13              0.798              0.980
3:                  2.16              0.728              0.957
4:                  2.20              0.633              0.914
5:                  1.99                 NA                 NA
6:                  2.13              0.444              0.895
7:                  2.16              0.320              0.785
8:                  2.20              0.190              0.612
> 
> ####  other examples ####
> # one strata variable
> fitS <- coxph(Surv(time,event)~strata(X1)+X2,
+               data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> predictCox(fitS)
    observation strata times cumhazard survival
 1:           1      0   0.6    0.0256   0.9747
 2:           2      0   1.0    0.0789   0.9241
 3:           3      0   1.8    0.1070   0.8986
 4:           4      0   2.1    0.1358   0.8730
 5:           5      0   2.2    0.1950   0.8228
 6:           6      0   2.5    0.2273   0.7967
 7:           7      0   2.7    0.2607   0.7705
 8:           8      0   3.0    0.2951   0.7445
 9:           9      0   3.2    0.2951   0.7445
10:          10      0   3.5    0.3319   0.7176
11:          11      0   3.6    0.3700   0.6907
12:          12      0   3.7    0.4095   0.6640
13:          13      0   4.0    0.4506   0.6372
14:          14      0   4.2    0.4506   0.6372
15:          15      0   4.7    0.5420   0.5816
16:          16      0   5.1    0.5420   0.5816
17:          17      0   5.5    0.5962   0.5509
18:          18      0   5.8    0.6532   0.5204
19:          19      0   5.9    0.7135   0.4899
20:          20      0   6.6    0.7815   0.4577
21:          21      0   6.9    0.8541   0.4256
22:          22      0   7.0    0.8541   0.4256
23:          23      0   7.2    0.8541   0.4256
24:          24      0   7.5    0.9456   0.3885
25:          25      0   7.7    1.0518   0.3493
26:          26      0   8.4    1.1698   0.3104
27:          27      0   9.2    1.1698   0.3104
28:          28      0   9.5    1.1698   0.3104
29:          29      0   9.6    1.1698   0.3104
30:          30      0  11.0    1.4354   0.2380
31:          31      0  11.1    1.7896   0.1670
32:          32      0  11.5    1.7896   0.1670
33:          33      0  12.0    2.8520   0.0577
34:          34      1   3.6    0.6546   0.5197
    observation strata times cumhazard survival
> predictCox(fitS, newdata=nd, times = 1)
   observation strata times cumhazard survival
1:           1      0     1    0.1205    0.886
2:           2      0     1    0.0743    0.928
3:           3      0     1    0.0743    0.928
4:           4      0     1    0.0743    0.928
> 
> # two strata variables
> set.seed(1)
> d$U=sample(letters[1:5],replace=TRUE,size=NROW(d))
> d$V=sample(letters[4:10],replace=TRUE,size=NROW(d))
> nd$U=sample(letters[1:5],replace=TRUE,size=NROW(nd))
> nd$V=sample(letters[4:10],replace=TRUE,size=NROW(nd))
> fit2S <- coxph(Surv(time,event)~X1+strata(U)+strata(V)+X2,
+               data=d, ties="breslow", x = TRUE, y = TRUE)
Warning in fitter(X, Y, istrat, offset, init, control, weights = weights,  :
  Loglik converged before variable  1 ; coefficient may be infinite. 
> 
> cbind(survival::basehaz(fit2S),predictCox(fit2S,type="cumhazard")$cumhazard)
         hazard time strata predictCox(fit2S, type = "cumhazard")$cumhazard
1  0.000000e+00  5.9   a, d                                    0.000000e+00
2  0.000000e+00  9.2   a, e                                    0.000000e+00
3  5.773970e-01  1.0   a, g                                    5.773970e-01
4  1.443493e+00  2.5   a, g                                    1.443493e+00
5  1.443493e+00 11.5   a, g                                    1.443493e+00
6  5.773970e-01  0.6   a, h                                    5.773970e-01
7  2.309588e+00  2.7   a, h                                    2.309588e+00
8  4.330478e-01  4.0   a, i                                    4.330478e-01
9  1.010445e+00  4.7   a, i                                    1.010445e+00
10 1.010445e+00  9.6   a, i                                    1.010445e+00
11 1.732191e+00  4.7   a, j                                    1.732191e+00
12 1.732191e+00  3.7   b, d                                    1.732191e+00
13 0.000000e+00  7.2   b, f                                    0.000000e+00
14 1.732191e+00 12.0   b, f                                    1.732191e+00
15 8.660955e-01  2.2   b, g                                    8.660955e-01
16 8.660955e-01  5.1   b, g                                    8.660955e-01
17 8.660955e-01  6.9   b, h                                    8.660955e-01
18 2.598287e+00 11.0   b, h                                    2.598287e+00
19 8.660955e-01  2.1   b, i                                    8.660955e-01
20 8.660955e-01  3.2   b, i                                    8.660955e-01
21 1.732191e+00  6.6   b, j                                    1.732191e+00
22 7.922907e-09  3.6   c, e                                    7.922907e-09
23 1.732191e+00 11.1   c, e                                    1.732191e+00
24 8.660955e-01  1.8   c, i                                    8.660955e-01
25 8.660955e-01  7.0   c, i                                    8.660955e-01
26 0.000000e+00  2.2   d, d                                    0.000000e+00
27 0.000000e+00  9.5   d, d                                    0.000000e+00
28 1.732191e+00  8.4   d, f                                    1.732191e+00
29 1.732191e+00  1.0   d, g                                    1.732191e+00
30 4.330478e-01  5.9   d, h                                    4.330478e-01
31 1.010445e+00  7.5   d, h                                    1.010445e+00
32 2.742636e+00  7.7   d, h                                    2.742636e+00
33 0.000000e+00  4.2   d, j                                    0.000000e+00
34 1.732191e+00  5.8   e, d                                    1.732191e+00
35 1.732191e+00  3.0   e, f                                    1.732191e+00
36 8.660955e-01  3.5   e, i                                    8.660955e-01
37 2.598287e+00  5.5   e, i                                    2.598287e+00
38 5.773970e-01  2.2   e, j                                    5.773970e-01
39 1.443493e+00  3.6   e, j                                    1.443493e+00
40 1.443493e+00  9.2   e, j                                    1.443493e+00
> predictCox(fit2S)
    observation strata times cumhazard survival
 1:           1   a, d   5.9  0.00e+00   1.0000
 2:           2   a, e   9.2  0.00e+00   1.0000
 3:           3   a, g   1.0  5.77e-01   0.5614
 4:           4   a, g   2.5  1.44e+00   0.2361
 5:           5   a, g  11.5  1.44e+00   0.2361
 6:           6   a, h   0.6  5.77e-01   0.5614
 7:           7   a, h   2.7  2.31e+00   0.0993
 8:           8   a, i   4.0  4.33e-01   0.6485
 9:           9   a, i   4.7  1.01e+00   0.3641
10:          10   a, i   9.6  1.01e+00   0.3641
11:          11   a, j   4.7  1.73e+00   0.1769
12:          12   b, d   3.7  1.73e+00   0.1769
13:          13   b, f   7.2  0.00e+00   1.0000
14:          14   b, f  12.0  1.73e+00   0.1769
15:          15   b, g   2.2  8.66e-01   0.4206
16:          16   b, g   5.1  8.66e-01   0.4206
17:          17   b, h   6.9  8.66e-01   0.4206
18:          18   b, h  11.0  2.60e+00   0.0744
19:          19   b, i   2.1  8.66e-01   0.4206
20:          20   b, i   3.2  8.66e-01   0.4206
21:          21   b, j   6.6  1.73e+00   0.1769
22:          22   c, e   3.6  7.92e-09   1.0000
23:          23   c, e  11.1  1.73e+00   0.1769
24:          24   c, i   1.8  8.66e-01   0.4206
25:          25   c, i   7.0  8.66e-01   0.4206
26:          26   d, d   2.2  0.00e+00   1.0000
27:          27   d, d   9.5  0.00e+00   1.0000
28:          28   d, f   8.4  1.73e+00   0.1769
29:          29   d, g   1.0  1.73e+00   0.1769
30:          30   d, h   5.9  4.33e-01   0.6485
31:          31   d, h   7.5  1.01e+00   0.3641
32:          32   d, h   7.7  2.74e+00   0.0644
33:          33   d, j   4.2  0.00e+00   1.0000
34:          34   e, d   5.8  1.73e+00   0.1769
35:          35   e, f   3.0  1.73e+00   0.1769
36:          36   e, i   3.5  8.66e-01   0.4206
37:          37   e, i   5.5  2.60e+00   0.0744
38:          38   e, j   2.2  5.77e-01   0.5614
39:          39   e, j   3.6  1.44e+00   0.2361
40:          40   e, j   9.2  1.44e+00   0.2361
    observation strata times cumhazard survival
> predictCox(fitS, newdata=nd, times = 3)
   observation strata times cumhazard survival
1:           1      0     3     0.451    0.637
2:           2      0     3     0.278    0.757
3:           3      0     3     0.278    0.757
4:           4      0     3     0.278    0.757
> 
> # left truncation
> test2 <- list(start=c(1,2,5,2,1,7,3,4,8,8), 
+               stop=c(2,3,6,7,8,9,9,9,14,17), 
+               event=c(1,1,1,1,1,1,1,0,0,0), 
+               x=c(1,0,0,1,0,1,1,1,0,0)) 
> m.cph <- coxph(Surv(start, stop, event) ~ 1, test2, x = TRUE)
> as.data.table(predictCox(m.cph))
Warning in predictCox(m.cph) :
  The current version of predictCox was not designed to handle left censoring 
The function may be used on own risks 

   observation times cumhazard  survival
1:           1     2 0.5000000 0.6065307
2:           2     3 0.8333333 0.4345982
3:           3     6 1.0333333 0.3558189
4:           4     7 1.2833333 0.2771121
5:           5     8 1.5333333 0.2158151
6:           6     9 1.9833333 0.1376098
7:           7    14 1.9833333 0.1376098
8:           8    17 1.9833333 0.1376098
> 
> basehaz(m.cph)
     hazard time
1 0.5000000    2
2 0.8333333    3
3 1.0333333    6
4 1.2833333    7
5 1.5333333    8
6 1.9833333    9
7 1.9833333   14
8 1.9833333   17
> 
> 
> 
> cleanEx()

detaching ‘package:data.table’, ‘package:survival’

> nameEx("predictCoxPL")
> ### * predictCoxPL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictCoxPL
> ### Title: Computation of survival probabilities from Cox regression models
> ###   using the product limit estimator.
> ### Aliases: predictCoxPL
> 
> ### ** Examples
> 
> library(survival)
> 
> #### generate data ####
> set.seed(10)
> d <- sampleData(40,outcome="survival")
> nd <- sampleData(4,outcome="survival")
> d$time <- round(d$time,1)
> 
> #### Cox model ####
> fit <- coxph(Surv(time,event)~ X1 + X2 + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## exponential approximation
> predictCox(fit, newdata = d, times = 1:5)
     observation times cumhazard survival
  1:           1     1   0.02767 9.73e-01
  2:           2     1   0.01904 9.81e-01
  3:           3     1   0.00346 9.97e-01
  4:           4     1   0.09274 9.11e-01
  5:           5     1   0.01844 9.82e-01
 ---                                     
196:          36     5   3.99435 1.84e-02
197:          37     5   2.10055 1.22e-01
198:          38     5   0.04125 9.60e-01
199:          39     5  29.60459 1.39e-13
200:          40     5   0.68889 5.02e-01
> 
> ## product limit
> predictCoxPL(fit, newdata = d, times = 1:5)
     observation times cumhazard survival
  1:           1     1   0.02767  0.97246
  2:           2     1   0.01904  0.98102
  3:           3     1   0.00346  0.99655
  4:           4     1   0.09274  0.90869
  5:           5     1   0.01844  0.98161
 ---                                     
196:          36     5   3.99435  0.00262
197:          37     5   2.10055  0.08913
198:          38     5   0.04125  0.95949
199:          39     5  29.60459  0.14730
200:          40     5   0.68889  0.48818
> 
> #### stratified Cox model ####
> fitS <- coxph(Surv(time,event)~ X1 + strata(X2) + X6,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## exponential approximation
> predictCox(fitS, newdata = d, times = 1:5)
     observation strata times cumhazard survival
  1:           1      0     1   0.02680 9.74e-01
  2:           2      0     1   0.01885 9.81e-01
  3:           3      0     1   0.00378 9.96e-01
  4:           4      0     1   0.08365 9.20e-01
  5:           5      0     1   0.01830 9.82e-01
 ---                                            
196:          36      0     5   3.62189 2.67e-02
197:          37      0     5   1.97830 1.38e-01
198:          38      0     5   0.04899 9.52e-01
199:          39      1     5  17.24685 3.23e-08
200:          40      0     5   0.69291 5.00e-01
> 
> ## product limit
> predictCoxPL(fitS, newdata = d, times = 1:5)
     observation strata times cumhazard survival
  1:           1      0     1   0.02680    0.973
  2:           2      0     1   0.01885    0.981
  3:           3      0     1   0.00378    0.996
  4:           4      0     1   0.08365    0.916
  5:           5      0     1   0.01830    0.982
 ---                                            
196:          36      0     5   3.62189    0.012
197:          37      0     5   1.97830    0.113
198:          38      0     5   0.04899    0.952
199:          39      1     5  17.24685    5.625
200:          40      0     5   0.69291    0.489
> 
> #### fully stratified Cox model ####
> fitS <- coxph(Surv(time,event)~ 1,
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## product limit
> GS <- survfit(Surv(time,event)~1, data = d)
> range(predictCoxPL(fitS)$survival - GS$surv)
[1] 0.000000e+00 1.110223e-16
> 
> fitS <- coxph(Surv(time,event)~ strata(X2),
+              data=d, ties="breslow", x = TRUE, y = TRUE)
> 
> ## product limit
> GS <- survfit(Surv(time,event)~X2, data = d)
> range(predictCoxPL(fitS)$survival - GS$surv)
[1] 0.000000e+00 2.220446e-16
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("predictRisk")
> ### * predictRisk
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictRisk
> ### Title: Extrating predicting risks from regression models
> ### Aliases: predictRisk predictRisk.CauseSpecificCox
> ###   predictRisk.riskRegression predictRisk.FGR predictRisk.prodlim
> ###   predictRisk.rfsrc predictRisk.aalen predictRisk.ARR
> ###   predictRisk.cox.aalen predictRisk.coxph predictRisk.cph
> ###   predictRisk.default predictRisk.matrix predictRisk.pecCtree
> ###   predictRisk.pecCforest predictRisk.psm predictRisk.selectCox
> ###   predictRisk.survfit predictRisk.randomForest predictRisk.lrm
> ###   predictRisk.glm predictRisk.rpart predictRisk.gbm
> ###   predictRisk.flexsurvreg predictRisk.double predictRisk.integer
> ###   predictRisk.factor predictRisk.numeric predictRisk.formula
> ###   predictRisk.BinaryTree predictRisk.coxphTD predictRisk.CSCTD
> ###   predictRisk.coxph.penal predictRisk.ranger predictRisk.penfitS3
> ###   predictRisk.SuperPredictor predictRisk.singleEventCB predictRisk.wglm
> ### Keywords: survival
> 
> ### ** Examples
> 
> ## binary outcome
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: survival
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> set.seed(7)
> d <- sampleData(80,outcome="binary")
> nd <- sampleData(80,outcome="binary")
> fit <- lrm(Y~X1+X8,data=d)
> predictRisk(fit,newdata=nd)
 [1] 0.7339412 0.5205004 0.6501073 0.5979307 0.5552337 0.6813442 0.5138679
 [8] 0.4869184 0.5723498 0.7074138 0.4503456 0.6303146 0.6940030 0.7019831
[15] 0.7304874 0.5405902 0.6450002 0.6896565 0.6689911 0.6865119 0.7344731
[22] 0.6689586 0.6906598 0.6615316 0.6682134 0.7072245 0.5725908 0.6725140
[29] 0.7493084 0.5723684 0.5466048 0.5498836 0.6665991 0.4635920 0.6969143
[36] 0.5879416 0.5341623 0.6023531 0.5320208 0.6121940 0.5766031 0.4807605
[43] 0.7727554 0.5650180 0.5466259 0.6760755 0.6716273 0.6953790 0.6627699
[50] 0.6865030 0.7738892 0.5867579 0.7673772 0.5591252 0.6120579 0.7014891
[57] 0.5616479 0.6084543 0.5823368 0.4629641 0.5386492 0.7027465 0.6637092
[64] 0.6194466 0.4777845 0.4645041 0.5229923 0.5819439 0.5879641 0.5579212
[71] 0.6642978 0.5665127 0.4391573 0.4995590 0.6802095 0.5770284 0.5952840
[78] 0.5303929 0.5633104 0.7699667
> ## Not run: 
> ##D library(SuperLearner)
> ##D set.seed(1)
> ##D sl = SuperLearner(Y = d$Y, X = d[,-1], family = binomial(),
> ##D       SL.library = c("SL.mean", "SL.glmnet", "SL.randomForest"))
> ## End(Not run)
> 
> ## survival outcome
> # generate survival data
> library(prodlim)
> set.seed(100)
> d <- sampleData(100,outcome="survival")
> d[,X1:=as.numeric(as.character(X1))]
> d[,X2:=as.numeric(as.character(X2))]
> # then fit a Cox model
> library(rms)
> cphmodel <- cph(Surv(time,event)~X1+X2,data=d,surv=TRUE,x=TRUE,y=TRUE)
> # or via survival
> library(survival)
> coxphmodel <- coxph(Surv(time,event)~X1+X2,data=d,x=TRUE,y=TRUE)
> 
> # Extract predicted survival probabilities 
> # at selected time-points:
> ttt <- quantile(d$time)
> # for selected predictor values:
> ndat <- data.frame(X1=c(0.25,0.25,-0.05,0.05),X2=c(0,1,0,1))
> # as follows
> predictRisk(cphmodel,newdata=ndat,times=ttt)
            [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 0.010423552 0.2498546 0.4661259 0.6749391 0.9490180
[2,] 0.011569784 0.2733328 0.5019288 0.7129324 0.9633185
[3,] 0.007190205 0.1796201 0.3509290 0.5387894 0.8712277
[4,] 0.009034264 0.2204172 0.4193263 0.6221600 0.9240581
> predictRisk(coxphmodel,newdata=ndat,times=ttt)
            [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 0.010423555 0.2498546 0.4661259 0.6749389 0.9490178
[2,] 0.011569787 0.2733328 0.5019287 0.7129322 0.9633183
[3,] 0.007190219 0.1796204 0.3509294 0.5387898 0.8712279
[4,] 0.009034276 0.2204174 0.4193266 0.6221602 0.9240581
> 
> # stratified cox model
> sfit <- coxph(Surv(time,event)~strata(X1)+X2,data=d,x=TRUE,y=TRUE)
> predictRisk(sfit,newdata=d[1:3,],times=c(1,3,5,10))
           [,1]     [,2]      [,3]     [,4]
[1,] 0.07654315 0.281073 0.4322176 0.689776
[2,] 0.07654315 0.281073 0.4322176 0.689776
[3,] 0.07654315 0.281073 0.4322176 0.689776
> 
> ## simulate learning and validation data
> learndat <- sampleData(100,outcome="survival")
> valdat <- sampleData(100,outcome="survival")
> ## use the learning data to fit a Cox model
> library(survival)
> fitCox <- coxph(Surv(time,event)~X1+X2,data=learndat,x=TRUE,y=TRUE)
> ## suppose we want to predict the survival probabilities for all subjects
> ## in the validation data at the following time points:
> ## 0, 12, 24, 36, 48, 60
> psurv <- predictRisk(fitCox,newdata=valdat,times=seq(0,60,12))
> ## This is a matrix with event probabilities (1-survival)
> ## one column for each of the 5 time points
> ## one row for each validation set individual
> 
> # Do the same for a randomSurvivalForest model
> # library(randomForestSRC)
> # rsfmodel <- rfsrc(Surv(time,event)~X1+X2,data=learndat)
> # prsfsurv=predictRisk(rsfmodel,newdata=valdat,times=seq(0,60,12))
> # plot(psurv,prsfsurv)
> 
> ## Cox with ridge option
> f1 <- coxph(Surv(time,event)~X1+X2,data=learndat,x=TRUE,y=TRUE)
> f2 <- coxph(Surv(time,event)~ridge(X1)+ridge(X2),data=learndat,x=TRUE,y=TRUE)
> ## Not run: 
> ##D plot(predictRisk(f1,newdata=valdat,times=10),
> ##D      riskRegression:::predictRisk.coxph(f2,newdata=valdat,times=10),
> ##D      xlim=c(0,1),
> ##D      ylim=c(0,1),
> ##D      xlab="Unpenalized predicted survival chance at 10",
> ##D      ylab="Ridge predicted survival chance at 10")
> ## End(Not run)
> 
> ## competing risks
> 
> library(survival)
> library(riskRegression)
> library(prodlim)
> train <- prodlim::SimCompRisk(100)
> test <- prodlim::SimCompRisk(10)
> cox.fit  <- CSC(Hist(time,cause)~X1+X2,data=train)
> predictRisk(cox.fit,newdata=test,times=seq(1:10),cause=1)
             [,1]        [,2]       [,3]       [,4]       [,5]       [,6]
 [1,] 0.003336186 0.006815801 0.01619852 0.02672988 0.04254840 0.06207469
 [2,] 0.031154093 0.062123978 0.14073384 0.21892189 0.31623402 0.40920676
 [3,] 0.002135486 0.004370331 0.01041397 0.01724860 0.02764812 0.04069547
 [4,] 0.015269678 0.031098095 0.07285185 0.11851646 0.18515067 0.26350414
 [5,] 0.071858689 0.141485382 0.30494285 0.45213411 0.61501518 0.74365714
 [6,] 0.008438974 0.017143504 0.04034630 0.06571777 0.10222401 0.14483683
 [7,] 0.019114164 0.038834445 0.09045024 0.14615640 0.22589234 0.31715015
 [8,] 0.012909266 0.026116995 0.06098177 0.09834693 0.15043127 0.20869101
 [9,] 0.088712245 0.169974894 0.35189416 0.49656435 0.62685981 0.70423405
[10,] 0.014431815 0.029407277 0.06897824 0.11238172 0.17598556 0.25122048
            [,7]       [,8]       [,9]     [,10]
 [1,] 0.10014146 0.11107754 0.11107754 0.1566170
 [2,] 0.52199267 0.54231411 0.54231411 0.5854577
 [3,] 0.06697324 0.07473752 0.07473752 0.1084884
 [4,] 0.40501038 0.44254884 0.44254884 0.5868296
 [5,] 0.85808309 0.87165494 0.87165494 0.8886527
 [6,] 0.21937006 0.23879428 0.23879428 0.3087464
 [7,] 0.47403469 0.51371708 0.51371708 0.6569501
 [8,] 0.30273776 0.32546337 0.32546337 0.3987820
 [9,] 0.74636289 0.74893384 0.74893384 0.7499682
[10,] 0.38857610 0.42539186 0.42539186 0.5688372
> 
> ## with strata
> cox.fit2  <- CSC(list(Hist(time,cause)~strata(X1)+X2,Hist(time,cause)~X1+X2),data=train)
> predictRisk(cox.fit2,newdata=test,times=seq(1:10),cause=1)
             [,1]        [,2]        [,3]       [,4]       [,5]       [,6]
 [1,] 0.003408683 0.006817084 0.014309898 0.01918373 0.03858482 0.07252045
 [2,] 0.031858033 0.062417019 0.125586702 0.16409076 0.29136919 0.45125305
 [3,] 0.002183560 0.004372607 0.009202652 0.01235594 0.02508376 0.04776776
 [4,] 0.014921141 0.031035493 0.076679322 0.13563418 0.19232139 0.24677922
 [5,] 0.070581243 0.141808469 0.320150086 0.50265176 0.63413772 0.72648490
 [6,] 0.008612007 0.017146262 0.035664275 0.04755050 0.09280959 0.16678930
 [7,] 0.018683356 0.038764611 0.095183187 0.16690843 0.23453254 0.29813092
 [8,] 0.013172600 0.026136611 0.053982039 0.07166659 0.13690221 0.23793972
 [9,] 0.091973643 0.173528151 0.323325921 0.40329682 0.59785720 0.71952743
[10,] 0.014101554 0.029346853 0.072605636 0.12867447 0.18281979 0.23507918
            [,7]       [,8]       [,9]      [,10]
 [1,] 0.11733823 0.11733823 0.11733823 0.11733823
 [2,] 0.56711144 0.56711144 0.56711144 0.56711144
 [3,] 0.07887777 0.07887777 0.07887777 0.07887777
 [4,] 0.38320640 0.44483827 0.44483827 0.60016503
 [5,] 0.85495833 0.87963912 0.87963912 0.89157834
 [6,] 0.25269590 0.25269590 0.25269590 0.25269590
 [7,] 0.45111926 0.51696557 0.51696557 0.66986176
 [8,] 0.34430205 0.34430205 0.34430205 0.34430205
 [9,] 0.74198812 0.74198812 0.74198812 0.74198812
[10,] 0.36717403 0.42747770 0.42747770 0.58216010
> 
> 
> 
> 
> cleanEx()

detaching ‘package:prodlim’, ‘package:rms’, ‘package:SparseM’,
  ‘package:Hmisc’, ‘package:ggplot2’, ‘package:Formula’,
  ‘package:survival’, ‘package:lattice’

> nameEx("riskLevelPlot")
> ### * riskLevelPlot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: riskLevelPlot
> ### Title: Level plots for risk prediction models
> ### Aliases: riskLevelPlot
> 
> ### ** Examples
> 
> 
> # ---------- logistic regression --------------------
> expit <- function(x){exp(x)/(1+exp(x))}
> partyData <- function(N){
+   Age <- runif(N,.5,15)
+   Parasites <- rnorm(N,mean=3.5-0.03*Age)
+   Fever <- factor(rbinom(N,1,expit(-3.5-.3*Age+.55*Parasites+0.15*Age*Parasites)))
+   data.frame(Fever,Age,Parasites)
+ }
> d <- partyData(100)
> f <- glm(Fever~Age+Parasites,data=d,family="binomial")
> riskLevelPlot(f,Fever~Age+Parasites,d)
> if (requireNamespace("randomForest",quietly=TRUE)){
+ rf <- randomForest::randomForest(Fever~Age+Parasites,data=d)
+ riskLevelPlot(f,Fever~Age+Parasites,d)
+ riskLevelPlot(rf,Fever~Age+Parasites,d)
+ }
> 
> # ---------- survival analysis --------------------
> 
> # --simulate an artificial data frame
> # with survival response and three predictors
> 
> library(survival)
> library(prodlim)
> set.seed(140515)
> sdat <- sampleData(43,outcome="survival")
> # -- fit a Cox regression model 
> survForm = Surv(time,event) ~ X8 + X9
> cox <- coxph(survForm, data = sdat,x=TRUE)
> 
> # --choose a time horizon for the predictions and plot the risks
> timeHorizon <- floor(median(sdat$time))
> riskLevelPlot(cox, survForm, data = sdat, horizon = timeHorizon)
> 
> # ---------- competing risks --------------------
> 
> # -- simulate an artificial data frame
> # with competing cause response and three predictors
> library(cmprsk)
> library(riskRegression)
> set.seed(140515)
> crdat <- sampleData(49)
> 
> # -- fit a cause-specific Cox regression model
> crForm <- Hist(time,event)~X8+X9
> csCox  <- CSC(crForm, data=crdat)
> 
> # -- choose a time horizon and plot the risk for a given cause
> timeHorizon <- floor(median(crdat$time))
> riskLevelPlot(csCox, crForm, data = crdat, horizon = timeHorizon, cause = 1)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:cmprsk’, ‘package:prodlim’, ‘package:survival’

> nameEx("riskRegression")
> ### * riskRegression
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: riskRegression
> ### Title: Risk Regression Fits a regression model for the risk of an event
> ###   - allowing for competing risks.
> ### Aliases: riskRegression ARR LRR
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> data(Melanoma,package="riskRegression")
> ## tumor thickness on the log-scale
> Melanoma$logthick <- log(Melanoma$thick)
> 
> # Single binary factor
> 
> ## absolute risk regression
> library(survival)
> library(prodlim)
> fit.arr <- ARR(Hist(time,status)~sex,data=Melanoma,cause=1)
> print(fit.arr)
Competing risks regression model 

IPCW weights: marginal Kaplan-Meier for the censoring distribution.
Link: 'log' yielding absolute risk ratios
No covariates with time-varying coefficient specified.

Time constant regression coefficients:
 Variable Levels Coef Lower Upper  Pvalue
      sex   Male 1.87  1.17  3.01 0.00927


Note: The coefficients (Coef) are absolute risk ratios 
> # show predicted cumulative incidences
> plot(fit.arr,col=3:4,newdata=data.frame(sex=c("Female","Male")))
> 
> ## compare with non-parametric Aalen-Johansen estimate
> library(prodlim)
> fit.aj <- prodlim(Hist(time,status)~sex,data=Melanoma)
> plot(fit.aj,conf.int=FALSE)
> plot(fit.arr,add=TRUE,col=3:4,newdata=data.frame(sex=c("Female","Male")))
> 
> ## with time-dependent effect
> fit.tarr <- ARR(Hist(time,status)~strata(sex),data=Melanoma,cause=1)
> plot(fit.tarr,newdata=data.frame(sex=c("Female","Male")))
> 
> ## logistic risk regression
> fit.lrr <- LRR(Hist(time,status)~sex,data=Melanoma,cause=1)
> summary(fit.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.013"    
770  "1.064"    
1100 "1.122"    
1700 "1.198"    
3300 "1.431"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 sexMale (numeric)

Time constant regression coefficients:

  Factor  Coef exp(Coef) StandardError     z         CI_95   Pvalue
 sexMale 0.832     2.298         0.319 2.605 [1.229;4.298] 0.009184


Note: The values exp(Coef) are odds ratios 
> 
> 
> # Single continuous factor
> 
> ## tumor thickness on the log-scale
> Melanoma$logthick <- log(Melanoma$thick)
> 
> ## absolute risk regression 
> fit2.arr <- ARR(Hist(time,status)~logthick,data=Melanoma,cause=1)
> print(fit2.arr)
Competing risks regression model 

IPCW weights: marginal Kaplan-Meier for the censoring distribution.
Link: 'log' yielding absolute risk ratios
No covariates with time-varying coefficient specified.

Time constant regression coefficients:
 Variable Levels Coef Lower Upper Pvalue
 logthick        1.87  1.49  2.35 <1e-04


Note: The coefficients (Coef) are absolute risk ratios 
> # show predicted cumulative incidences
> plot(fit2.arr,col=1:5,newdata=data.frame(logthick=quantile(Melanoma$logthick)))
> 
> ## comparison with nearest neighbor non-parametric Aalen-Johansen estimate
> library(prodlim)
> fit2.aj <- prodlim(Hist(time,status)~logthick,data=Melanoma)
> plot(fit2.aj,conf.int=FALSE,newdata=data.frame(logthick=quantile(Melanoma$logthick)))
> plot(fit2.arr,add=TRUE,col=1:5,lty=3,newdata=data.frame(logthick=quantile(Melanoma$logthick)))
> 
> ## logistic risk regression
> fit2.lrr <- LRR(Hist(time,status)~logthick,data=Melanoma,cause=1)
> summary(fit2.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.007"    
770  "1.040"    
1100 "1.074"    
1700 "1.120"    
3300 "1.283"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 logthick (numeric)

Time constant regression coefficients:

   Factor  Coef exp(Coef) StandardError     z         CI_95  Pvalue
 logthick 1.003     2.726         0.214 4.677 [1.790;4.149] < 1e-04


Note: The values exp(Coef) are odds ratios 
> 
> ## change model for censoring weights
> library(rms)
Loading required package: Hmisc
Loading required package: lattice
Loading required package: Formula
Loading required package: ggplot2

Attaching package: ‘Hmisc’

The following objects are masked from ‘package:base’:

    format.pval, units

Loading required package: SparseM

Attaching package: ‘SparseM’

The following object is masked from ‘package:base’:

    backsolve

> fit2a.lrr <- LRR(Hist(time,status)~logthick,
+                  data=Melanoma,
+                  cause=1,
+                  cens.model="cox",
+                  cens.formula=~sex+epicel+ulcer+age+logthick)
> summary(fit2a.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
a Cox model for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.007"    
770  "1.040"    
1100 "1.074"    
1700 "1.120"    
3300 "1.283"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 logthick (numeric)

Time constant regression coefficients:

   Factor  Coef exp(Coef) StandardError     z         CI_95  Pvalue
 logthick 1.003     2.726         0.214 4.677 [1.790;4.149] < 1e-04


Note: The values exp(Coef) are odds ratios 
> 
> ##  compare prediction performance
> Score(list(ARR=fit2.arr,AJ=fit2.aj,LRR=fit2.lrr),formula=Hist(time,status)~1,data=Melanoma)

Metric AUC:

Results by model:

   model times  AUC lower upper
1:   ARR  2006 60.0  55.5  64.5
2:    AJ  2006 72.6  64.4  80.9
3:   LRR  2006 73.8  65.6  82.0

Results of model comparisons:

   times model reference delta.AUC lower upper     p
1:  2006    AJ       ARR      12.6   5.1  20.1 9e-04
2:  2006   LRR       ARR      13.8   6.4  21.2 3e-04
3:  2006   LRR        AJ       1.2  -0.5   2.9 2e-01

NOTE: Values are multiplied by 100 and given in %.
NOTE: The higher AUC the better.

Metric Brier:

Results by model:

        model times Brier lower upper
1: Null model  2006  17.7  13.4  22.0
2:        ARR  2006  68.9  63.0  74.9
3:         AJ  2006  15.9  12.3  19.4
4:        LRR  2006  34.8  30.9  38.8

Results of model comparisons:

   times model  reference delta.Brier lower upper            p
1:  2006   ARR Null model        51.2  42.1  60.3 2.028954e-28
2:  2006    AJ Null model        -1.9  -3.9   0.2 7.686697e-02
3:  2006   LRR Null model        17.1  10.5  23.7 3.785925e-07
4:  2006    AJ        ARR       -53.1 -61.2 -44.9 2.424144e-37
5:  2006   LRR        ARR       -34.1 -38.1 -30.1 1.616407e-62
6:  2006   LRR         AJ        19.0  13.7  24.2 1.290679e-12

NOTE: Values are multiplied by 100 and given in %.
NOTE: The lower Brier the better.
> 
> 
> # multiple regression
> library(riskRegression)
> library(prodlim)
> # absolute risk model
> multi.arr <- ARR(Hist(time,status)~logthick+sex+age+ulcer,data=Melanoma,cause=1)
> 
> # stratified model allowing different baseline risk for the two gender
> multi.arr <- ARR(Hist(time,status)~thick+strata(sex)+age+ulcer,data=Melanoma,cause=1)
> 
> # stratify by a continuous variable: strata(age)
> multi.arr <- ARR(Hist(time,status)~tp(thick,power=0)+strata(age)+sex+ulcer,
+                  data=Melanoma,
+                  cause=1)
> 
> fit.arr2a <- ARR(Hist(time,status)~tp(thick,power=1),data=Melanoma,cause=1)
> summary(fit.arr2a)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'relative' yielding absolute risk ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.015"    
770  "1.082"    
1100 "1.145"    
1700 "1.195"    
3300 "1.156"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 thick (numeric)

Time constant regression coefficients:

 Factor     Coef exp(Coef) StandardError        z         CI_95  Pvalue
  thick 4.44e-05  1.00e+00      7.33e-06 6.05e+00 [1.000;1.000] < 1e-04


Note: The values exp(Coef) are absolute risk ratios 


Note:The coeffient(s) for the following variable(s)
thick are interpreted as per factor unit multiplied by time^power.
> fit.arr2b <- ARR(Hist(time,status)~timevar(thick),data=Melanoma,cause=1)
> summary(fit.arr2b)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'relative' yielding absolute risk ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)
 thick (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept) thick  
230  "0.993"     "1.008"
770  "0.984"     "1.033"
1100 "1.022"     "1.042"
1700 "1.066"     "1.050"
3300 "1.241"     "1.043"

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Time constant regression coefficients:

No covariates with time-constant coefficients specified.
> 
> ## logistic risk model
> fit.lrr <- LRR(Hist(time,status)~thick,data=Melanoma,cause=1)
> summary(fit.lrr)

riskRegression: Competing risks regression model 

IPCW estimation. The weights are based on
the Kaplan-Meier estimate for the censoring distribution.

Link function: 'logistic' yielding odds ratios, see help(riskRegression).

Covariates with time-varying effects:

 Intercept (numeric)

The effects of these variables depend on time.The column 'Intercept' is the baseline risk where all the covariates have value zero

     (Intercept)
230  "1.007"    
770  "1.050"    
1100 "1.098"    
1700 "1.158"    
3300 "1.347"    

Shown are selected time points, use

plot.riskRegression

to investigate the full shape.


Covariates with time-constant effects:

 thick (numeric)

Time constant regression coefficients:

 Factor   Coef exp(Coef) StandardError      z         CI_95  Pvalue
  thick 0.1942    1.2143        0.0477 4.0690 [1.106;1.333] < 1e-04


Note: The values exp(Coef) are odds ratios 
> 
> 
> 
> 
> 
> ## nearest neighbor non-parametric Aalen-Johansen estimate
> library(prodlim)
> fit.aj <- prodlim(Hist(time,status)~thick,data=Melanoma)
> plot(fit.aj,conf.int=FALSE)
> 
> # prediction performance
> x <- Score(list(fit.arr2a,fit.arr2b,fit.lrr),
+              data=Melanoma,
+              formula=Hist(time,status)~1,
+              cause=1,
+              split.method="none")
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:rms’, ‘package:SparseM’, ‘package:Hmisc’,
  ‘package:ggplot2’, ‘package:Formula’, ‘package:lattice’,
  ‘package:survival’, ‘package:prodlim’

> nameEx("riskRegression.options")
> ### * riskRegression.options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: riskRegression.options
> ### Title: Global options for 'riskRegression'
> ### Aliases: riskRegression.options
> 
> ### ** Examples
> 
> options <- riskRegression.options()
> 
> ## add new method.predictRiskIID
> riskRegression.options(method.predictRiskIID = c(options$method.predictRiskIID,"xx"))
> 
> riskRegression.options()
$method.predictRisk
 [1] "predictRisk.ARR"              "predictRisk.BinaryTree"      
 [3] "predictRisk.CauseSpecificCox" "predictRisk.Cforest"         
 [5] "predictRisk.coxph"            "predictRisk.coxph.penal"     
 [7] "predictRisk.coxphTD"          "predictRisk.cph"             
 [9] "predictRisk.CSCTD"            "predictRisk.Ctree"           
[11] "predictRisk.default"          "predictRisk.double"          
[13] "predictRisk.factor"           "predictRisk.FGR"             
[15] "predictRisk.flexsurvreg"      "predictRisk.formula"         
[17] "predictRisk.gbm"              "predictRisk.glm"             
[19] "predictRisk.integer"          "predictRisk.lrm"             
[21] "predictRisk.matrix"           "predictRisk.numeric"         
[23] "predictRisk.penfitS3"         "predictRisk.prodlim"         
[25] "predictRisk.psm"              "predictRisk.randomForest"    
[27] "predictRisk.ranger"           "predictRisk.rfsrc"           
[29] "predictRisk.riskRegression"   "predictRisk.rpart"           
[31] "predictRisk.selectCox"        "predictRisk.SmcFcs"          
[33] "predictRisk.SuperPredictor"   "predictRisk.survfit"         
[35] "predictRisk.wglm"            

$method.predictRiskIID
[1] "predictRiskIID.CauseSpecificCox" "predictRiskIID.coxph"           
[3] "predictRiskIID.cph"              "predictRiskIID.default"         
[5] "predictRiskIID.glm"              "predictRiskIID.phreg"           
[7] "predictRiskIID.wglm"             "xx"                             

> 
> 
> 
> cleanEx()
> nameEx("rowCenter_cpp")
> ### * rowCenter_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCenter_cpp
> ### Title: Apply - by row
> ### Aliases: rowCenter_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 2, FUN = "-", STATS = 1:5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    0   -1   -2   -3   -4
[2,]    0   -1   -2   -3   -4
[3,]    0   -1   -2   -3   -4
[4,]    0   -1   -2   -3   -4
[5,]    0   -1   -2   -3   -4
[6,]    0   -1   -2   -3   -4
> rowCenter_cpp(x, 1:5 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    0   -1   -2   -3   -4
[2,]    0   -1   -2   -3   -4
[3,]    0   -1   -2   -3   -4
[4,]    0   -1   -2   -3   -4
[5,]    0   -1   -2   -3   -4
[6,]    0   -1   -2   -3   -4
> 
> rowCenter_cpp(x, colMeans(x) )
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    0    0    0    0
[2,]    0    0    0    0    0
[3,]    0    0    0    0    0
[4,]    0    0    0    0    0
[5,]    0    0    0    0    0
[6,]    0    0    0    0    0
> 
> 
> 
> cleanEx()
> nameEx("rowCumProd")
> ### * rowCumProd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCumProd
> ### Title: Apply cumprod in each row
> ### Aliases: rowCumProd
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> rowCumProd(x)
     [,1] [,2]
[1,]    1    5
[2,]    2   12
[3,]    3   21
[4,]    4   32
> 
> 
> 
> cleanEx()
> nameEx("rowCumSum")
> ### * rowCumSum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowCumSum
> ### Title: Apply cumsum in each row
> ### Aliases: rowCumSum
> 
> ### ** Examples
> 
> x <- matrix(1:8,ncol=2)
> rowCumSum(x)
     [,1] [,2]
[1,]    1    6
[2,]    2    8
[3,]    3   10
[4,]    4   12
> 
> 
> 
> cleanEx()
> nameEx("rowMultiply_cpp")
> ### * rowMultiply_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowMultiply_cpp
> ### Title: Apply * by row
> ### Aliases: rowMultiply_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 2, FUN = "*", STATS = 1:5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
[3,]    1    2    3    4    5
[4,]    1    2    3    4    5
[5,]    1    2    3    4    5
[6,]    1    2    3    4    5
> rowMultiply_cpp(x, 1:5 )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    1    2    3    4    5
[3,]    1    2    3    4    5
[4,]    1    2    3    4    5
[5,]    1    2    3    4    5
[6,]    1    2    3    4    5
> 
> rowMultiply_cpp(x, 1/colMeans(x) )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    1    1    1    1    1
[3,]    1    1    1    1    1
[4,]    1    1    1    1    1
[5,]    1    1    1    1    1
[6,]    1    1    1    1    1
> 
> 
> 
> 
> cleanEx()
> nameEx("rowPaste")
> ### * rowPaste
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowPaste
> ### Title: Collapse Rows of Characters.
> ### Aliases: rowPaste
> 
> ### ** Examples
> 
> ## Not run: 
> ##D M <- matrix(letters,nrow = 26, ncol = 2)
> ##D rowPaste(M)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rowScale_cpp")
> ### * rowScale_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowScale_cpp
> ### Title: Apply / by row
> ### Aliases: rowScale_cpp
> 
> ### ** Examples
> 
> x <- matrix(1,6,5)
> sweep(x, MARGIN = 2, FUN = "/", STATS = 1:5)
     [,1] [,2]      [,3] [,4] [,5]
[1,]    1  0.5 0.3333333 0.25  0.2
[2,]    1  0.5 0.3333333 0.25  0.2
[3,]    1  0.5 0.3333333 0.25  0.2
[4,]    1  0.5 0.3333333 0.25  0.2
[5,]    1  0.5 0.3333333 0.25  0.2
[6,]    1  0.5 0.3333333 0.25  0.2
> rowScale_cpp(x, 1:5 )
     [,1] [,2]      [,3] [,4] [,5]
[1,]    1  0.5 0.3333333 0.25  0.2
[2,]    1  0.5 0.3333333 0.25  0.2
[3,]    1  0.5 0.3333333 0.25  0.2
[4,]    1  0.5 0.3333333 0.25  0.2
[5,]    1  0.5 0.3333333 0.25  0.2
[6,]    1  0.5 0.3333333 0.25  0.2
> 
> rowScale_cpp(x, colMeans(x) )
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    1    1    1    1
[2,]    1    1    1    1    1
[3,]    1    1    1    1    1
[4,]    1    1    1    1    1
[5,]    1    1    1    1    1
[6,]    1    1    1    1    1
> 
> 
> 
> cleanEx()
> nameEx("rowSumsCrossprod")
> ### * rowSumsCrossprod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rowSumsCrossprod
> ### Title: Apply crossprod and rowSums
> ### Aliases: rowSumsCrossprod
> 
> ### ** Examples
> 
> x <- matrix(1:10,nrow=5)
> y <- matrix(1:20,ncol=4)
> rowSumsCrossprod(x,y,0)
     [,1] [,2] [,3] [,4]
[1,]  185  460  735 1010
> 
> x <- matrix(1:10,nrow=5)
> y <- matrix(1:20,ncol=5)
> rowSumsCrossprod(x,y,1)
     [,1] [,2] [,3] [,4]
[1,]  575  630  685  740
> 
> 
> 
> cleanEx()
> nameEx("sampleData")
> ### * sampleData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sampleData
> ### Title: Simulate data with binary or time-to-event outcome
> ### Aliases: sampleData sampleDataTD
> 
> ### ** Examples
> 
> sampleData(10,outcome="binary")
          X6       X7         X8         X9         X10 X1 X2 X3 X4 X5 Y
 1: 62.83188 69.90200 -0.7074952 -0.4149946 -0.05612874  0  0  1  0  0 1
 2: 32.92562 58.16389  0.3645820 -0.3942900 -0.15579551  0  0  0  0  0 0
 3: 81.98332 54.77933  0.7685329 -0.0593134 -1.47075238  0  0  0  1  1 1
 4: 62.29880 62.84860 -0.1123462  1.1000254 -0.47815006  0  0  0  0  1 0
 5: 92.58918 59.32473  0.8811077  0.7631757  0.41794156  0  1  0  1  0 1
 6: 67.13264 72.00809  0.3981059 -0.1645236  1.35867955  0  0  0  0  1 0
 7: 49.35080 59.80380 -0.6120264 -0.2533617 -0.10278773  0  0  0  1  1 0
 8: 69.16090 63.44870  0.3411197  0.6969634  0.38767161  0  0  0  1  1 1
 9: 45.98854 60.14001 -1.1293631  0.5566632 -0.05380504  0  0  1  0  1 0
10: 41.19550 56.28363  1.4330237 -0.6887557 -1.37705956  0  0  0  1  0 0
> sampleData(10,outcome="survival")
          X6       X7          X8          X9        X10 X1 X2 X3 X4 X5
 1: 66.75281 50.42820  0.06016044 -0.50595746 -0.6357365  1  0  1  0  1
 2: 59.72160 65.88292 -0.58889449  1.34303883 -0.4616447  0  0  0  0  1
 3: 55.22897 51.67514  0.53149619 -0.21457941  1.4322822  0  0  0  1  1
 4: 46.05957 57.68235 -1.51839408 -0.17955653 -0.6506964  1  0  1  0  0
 5: 37.68810 54.42040  0.30655786 -0.10019074 -0.2073807  0  0  0  1  0
 6: 43.87212 56.24590 -1.53644982  0.71266631 -0.3928079  0  0  0  0  1
 7: 75.00043 70.43583 -0.30097613 -0.07356440 -0.3199929  0  0  0  1  1
 8: 50.68100 60.08698 -0.52827990 -0.03763417 -0.2791133  1  0  1  1  1
 9: 39.23360 53.56850 -0.65209478 -0.68166048  0.4941883  1  0  0  1  1
10: 88.03936 51.79697 -0.05689678 -0.32427027 -0.1773305  0  0  1  0  1
     eventtime  censtime      time event
 1:  0.6510013 11.207147 0.6510013     1
 2: 33.2805894  3.329060 3.3290603     0
 3:  6.2541901  8.982810 6.2541901     1
 4:  0.4511434  4.984784 0.4511434     1
 5:  8.0470010  3.565532 3.5655318     0
 6:  8.4900270  9.402165 8.4900270     1
 7:  3.7712936 16.588759 3.7712936     1
 8:  2.6758020 10.450697 2.6758020     1
 9:  7.2375769  5.686321 5.6863212     0
10:  0.6010126 10.420404 0.6010126     1
> sampleData(10,outcome="competing.risks")
          X6       X7          X8          X9         X10 X1 X2 X3 X4 X5
 1: 70.60966 55.07087 -1.73321841 -0.16437583  0.40940184  0  0  0  0  0
 2: 75.51162 45.55540  0.00213186  0.42069464  1.68887329  0  0  0  0  0
 3: 63.35221 56.79759 -0.63030033 -0.40024674  1.58658843  1  0  1  1  1
 4: 46.81939 62.85254 -0.34096858 -1.37020788 -0.33090780  0  1  0  0  0
 5: 77.44447 59.70138 -1.15657236  0.98783827 -2.28523554  0  0  0  0  1
 6: 29.99753 59.50911  1.80314191  1.51974503  2.49766159  0  0  0  1  0
 7: 51.82814 62.80410 -0.33113204 -0.30874057  0.66706617  0  0  0  0  1
 8: 56.16494 54.06771 -1.60551341 -1.25328976  0.54132734  0  1  1  1  0
 9: 57.50818 65.48389  0.19719344  0.64224131 -0.01339952  0  0  0  1  1
10: 75.30696 59.97328  0.26317565 -0.04470914  0.51010842  0  1  0  0  0
    eventtime1 eventtime2  censtime      time event
 1:   5.018722   1.027409  1.174009  1.027409     2
 2:   1.685831  13.170825 11.070312  1.685831     1
 3:   1.345442   7.824632  9.580784  1.345442     1
 4:   7.969699   9.779170  4.561721  4.561721     0
 5:   7.805580   6.255554 16.006193  6.255554     2
 6:  10.480238  11.454049 10.057011 10.057011     0
 7:  15.380297   8.698377  9.028321  8.698377     2
 8:   2.415957  13.271864 13.613713  2.415957     1
 9:  10.326071   9.982211  7.354809  7.354809     0
10:   3.432267   5.665905  1.740460  1.740460     0
> 
> 
> 
> cleanEx()
> nameEx("selectCox")
> ### * selectCox
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: selectCox
> ### Title: Backward variable selection in the Cox regression model
> ### Aliases: selectCox
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(pec)
Loading required package: prodlim

Attaching package: ‘pec’

The following objects are masked from ‘package:riskRegression’:

    ipcw, selectCox

> library(prodlim)
> data(GBSG2)
> library(survival)
> f <- selectCox(Surv(time,cens)~horTh+age+menostat+tsize+tgrade+pnodes+progrec+estrec ,
+ 	       data=GBSG2)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:pec’, ‘package:prodlim’

> nameEx("simActiveSurveillance")
> ### * simActiveSurveillance
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simActiveSurveillance
> ### Title: Simulate data of a hypothetical active surveillance prostate
> ###   cancer study
> ### Aliases: simActiveSurveillance
> 
> ### ** Examples
> 
> set.seed(71)
> simActiveSurveillance(3)
        age   lpsaden     ppb5     lmax ct1 diaggs erg.status     time event
1: 68.04504 -3.504668 2.024705 1.077346 cT1    3/3        neg 4.047567     0
2: 68.45207 -3.696001 5.321986 4.231017 cT1    3/3        pos 1.603210     1
3: 70.81464 -3.082855 3.428400 2.042447 cT1    GNA        neg 5.566821     0
> 
> 
> 
> cleanEx()
> nameEx("simMelanoma")
> ### * simMelanoma
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simMelanoma
> ### Title: Simulate data alike the Melanoma data
> ### Aliases: simMelanoma
> 
> ### ** Examples
> 
> set.seed(71)
> simMelanoma(3)
         ulcer      epicel  sex      age  logthick     thick       time status
1: not present     present Male 67.63431 -1.384208 0.2505222 3076.04823      0
2:     present not present Male 57.92951  1.446500 4.2482183 2179.31190      1
3:     present     present Male 60.48275  2.287579 9.8510608   25.85244      1
   ici
1:   0
2:   0
3:   3
> 
> 
> 
> cleanEx()
> nameEx("sliceMultiply_cpp")
> ### * sliceMultiply_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sliceMultiply_cpp
> ### Title: Apply * by slice
> ### Aliases: sliceMultiply_cpp sliceMultiplyPointer_cpp
> 
> ### ** Examples
> 
> x <- array(1, dim = c(2,6,5))
> M <- matrix(1:12,2,6)
> sweep(x, MARGIN = 1:2, FUN = "*", STATS = M)
, , 1

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 2

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 3

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 4

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 5

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

> sliceMultiply_cpp(x, M) 
, , 1

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 2

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 3

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 4

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

, , 5

     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

> 
> 
> 
> 
> cleanEx()
> nameEx("sliceScale_cpp")
> ### * sliceScale_cpp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sliceScale_cpp
> ### Title: Apply / by slice
> ### Aliases: sliceScale_cpp sliceScalePointer_cpp
> 
> ### ** Examples
> 
> x <- array(1, dim = c(2,6,5))
> M <- matrix(1:12,2,6)
> sweep(x, MARGIN = 1:2, FUN = "/", STATS = M)
, , 1

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 2

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 3

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 4

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 5

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

> sliceScale_cpp(x, M) 
, , 1

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 2

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 3

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 4

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

, , 5

     [,1]      [,2]      [,3]      [,4]      [,5]       [,6]
[1,]  1.0 0.3333333 0.2000000 0.1428571 0.1111111 0.09090909
[2,]  0.5 0.2500000 0.1666667 0.1250000 0.1000000 0.08333333

> 
> 
> 
> 
> cleanEx()
> nameEx("subjectWeights")
> ### * subjectWeights
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subjectWeights
> ### Title: Estimation of censoring probabilities at subject specific times
> ### Aliases: subjectWeights subjectWeights.none subjectWeights.km
> ###   subjectWeights.marginal subjectWeights.nonpar subjectWeights.cox
> ###   subjectWeights.aalen
> ### Keywords: survival
> 
> ### ** Examples
> 
> 
> library(prodlim)
> library(survival)
> dat=SimSurv(300)
> 
> dat <- dat[order(dat$time,-dat$status),]
> 
> # using the marginal Kaplan-Meier for the censoring times
> 
> WKM=subjectWeights(Hist(time,status)~X2,data=dat,method="marginal")
> plot(WKM$fit)
> WKM$fit

Call: prodlim::prodlim(formula = formula, data = data, reverse = TRUE)

Kaplan-Meier estimator for the censoring time survival function

No covariates

Right-censored response of a survival model

No.Observations: 300 

Pattern:
                Freq
 event          186 
 right.censored 114 
> WKM$weights
  [1] 1.00000000 0.99666667 0.99666667 0.99332215 0.99332215 0.99332215
  [7] 0.99332215 0.98994350 0.98994350 0.98994350 0.98654163 0.98313977
 [13] 0.98313977 0.98313977 0.98313977 0.98313977 0.97969015 0.97969015
 [19] 0.97969015 0.97969015 0.97620371 0.97620371 0.97620371 0.97620371
 [25] 0.97620371 0.97620371 0.97620371 0.97620371 0.97620371 0.97620371
 [31] 0.97260148 0.96899926 0.96539703 0.96539703 0.96539703 0.96539703
 [37] 0.96539703 0.96174022 0.96174022 0.96174022 0.95805539 0.95805539
 [43] 0.95805539 0.95805539 0.95805539 0.95805539 0.95805539 0.95428352
 [49] 0.95428352 0.95428352 0.95428352 0.95428352 0.95045106 0.95045106
 [55] 0.94660308 0.94660308 0.94660308 0.94660308 0.94660308 0.94269149
 [61] 0.93877991 0.93877991 0.93877991 0.93483546 0.93483546 0.93483546
 [67] 0.93483546 0.93084043 0.92684541 0.92684541 0.92283309 0.92283309
 [73] 0.91880325 0.91477341 0.91477341 0.91477341 0.91477341 0.91477341
 [79] 0.91067129 0.91067129 0.91067129 0.90653188 0.90653188 0.90653188
 [85] 0.90235431 0.90235431 0.90235431 0.90235431 0.90235431 0.89809792
 [91] 0.89384153 0.88958515 0.88958515 0.88958515 0.88958515 0.88958515
 [97] 0.88524571 0.88524571 0.88088489 0.88088489 0.88088489 0.87648047
[103] 0.87207604 0.86767162 0.86767162 0.86767162 0.86767162 0.86319908
[109] 0.85872655 0.85872655 0.85872655 0.85420694 0.85420694 0.85420694
[115] 0.85420694 0.85420694 0.85420694 0.85420694 0.84953914 0.84487134
[121] 0.84487134 0.84487134 0.84487134 0.84487134 0.84487134 0.84487134
[127] 0.84487134 0.84487134 0.83998769 0.83510404 0.83022039 0.82533674
[133] 0.82533674 0.82042402 0.82042402 0.82042402 0.82042402 0.82042402
[139] 0.81539075 0.81035747 0.81035747 0.81035747 0.80526088 0.80526088
[145] 0.80526088 0.80009895 0.80009895 0.80009895 0.80009895 0.80009895
[151] 0.79480029 0.78950162 0.78950162 0.78950162 0.78413086 0.78413086
[157] 0.78413086 0.78413086 0.77864743 0.77864743 0.77864743 0.77308566
[163] 0.77308566 0.76748359 0.76188152 0.76188152 0.76188152 0.76188152
[169] 0.75615309 0.75615309 0.75615309 0.75615309 0.75615309 0.75615309
[175] 0.75615309 0.75015187 0.74415066 0.74415066 0.73810065 0.73810065
[181] 0.73200065 0.72590064 0.71980063 0.71980063 0.71980063 0.71980063
[187] 0.71980063 0.71348659 0.71348659 0.71348659 0.71348659 0.71348659
[193] 0.70694085 0.70039510 0.69384935 0.68730360 0.68075785 0.67421210
[199] 0.67421210 0.67421210 0.67421210 0.66746998 0.66072786 0.66072786
[205] 0.66072786 0.66072786 0.65377283 0.65377283 0.65377283 0.65377283
[211] 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851
[217] 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851 0.64658851
[223] 0.63840385 0.63840385 0.63840385 0.63000380 0.62160375 0.61320370
[229] 0.61320370 0.60468698 0.60468698 0.59604859 0.58741021 0.58741021
[235] 0.58741021 0.58741021 0.57837313 0.57837313 0.56919260 0.56919260
[241] 0.56919260 0.56919260 0.56919260 0.56919260 0.56919260 0.55902845
[247] 0.55902845 0.54867607 0.54867607 0.53812461 0.53812461 0.53812461
[253] 0.52714247 0.52714247 0.51592667 0.50471088 0.50471088 0.49324018
[259] 0.49324018 0.48149636 0.46975255 0.45800873 0.45800873 0.44595587
[265] 0.44595587 0.43356821 0.42118055 0.42118055 0.40841750 0.40841750
[271] 0.40841750 0.40841750 0.39433414 0.38025078 0.38025078 0.36562575
[277] 0.35100072 0.33637569 0.32175066 0.32175066 0.32175066 0.32175066
[283] 0.30481641 0.30481641 0.28688603 0.26895566 0.26895566 0.24974454
[289] 0.24974454 0.22893249 0.22893249 0.22893249 0.20349555 0.17805861
[295] 0.15262166 0.12718472 0.10174778 0.10174778 0.06783185 0.03391593
> 
> # using the Cox model for the censoring times given X2
> 
> WCox=subjectWeights(Surv(time,status)~X2,data=dat,method="cox")
> WCox

Estimated inverse of the probability of censoring weights (subjectWeights)

Method for estimation:  Cox regression 
Handler function:  function (formula = formula(data), data = environment(formula), weights, subset, na.action = na.delete, method = c("efron", "breslow", "exact", "model.frame", "model.matrix"), singular.ok = FALSE, robust = FALSE, model = FALSE, x = FALSE, y = FALSE, se.fit = FALSE, linear.predictors = TRUE, residuals = TRUE, nonames = FALSE, eps = 1e-04, init, iter.max = 10, tol = 1e-09, surv = FALSE, time.inc, type = NULL, vartype = NULL, debug = FALSE, ...) 
{
    method <- match.arg(method)
    call <- match.call()
    if (!inherits(formula, "formula")) {
        if (inherits(formula, "Surv")) {
            xx <- function(x) formula(x)
            formula <- xx(paste(deparse(substitute(formula)), 1, sep = "~"))
        }
        else stop("Invalid formula")
    }
    callenv <- parent.frame()
    weights <- if (!missing(weights)) 
        eval(substitute(weights), data, callenv)
    subset <- if (!missing(subset)) 
        eval(substitute(subset), data, callenv)
    data <- modelData(data, formula, weights = weights, subset = subset, na.action = na.action, dotexpand = FALSE, callenv = callenv)
    nstrata <- 0
    Strata <- NULL
    odb <- .Options$debug
    if (length(odb) && is.logical(odb) && odb) 
        debug <- TRUE
    if (length(z <- attr(terms(formula, allowDotAsName = TRUE), "term.labels")) > 0 && any(z != ".")) {
        X <- Design(data, formula, specials = c("strat", "strata"))
        atrx <- attributes(X)
        atr <- atrx$Design
        nact <- atrx$na.action
        sformula <- atrx$sformula
        mmcolnames <- atr$mmcolnames
        if (method == "model.frame") 
            return(X)
        Terms <- terms(sformula, specials = c("strat", "strata"), data = data)
        asm <- atr$assume.code
        name <- atr$name
        specials <- attr(Terms, "specials")
        if (length(specials$strata)) 
            stop("cph supports strat(), not strata()")
        stra <- specials$strat
        cluster <- attr(X, "cluster")
        if (length(cluster)) {
            if (missing(robust)) 
                robust <- TRUE
            attr(X, "cluster") <- NULL
        }
        Terms.ns <- Terms
        if (length(stra)) {
            temp <- untangle.specials(Terms.ns, "strat", 1)
            Terms.ns <- Terms.ns[-temp$terms]
            Strata <- list()
            strataname <- attr(Terms, "term.labels")[stra - 1]
            j <- 0
            for (i in (1:length(asm))[asm == 8]) {
                nstrata <- nstrata + 1
                xi <- X[[i + 1]]
                levels(xi) <- paste(name[i], "=", levels(xi), sep = "")
                Strata[[nstrata]] <- xi
            }
            Strata <- interaction(as.data.frame(Strata), drop = TRUE)
        }
        xpres <- length(asm) && any(asm != 8)
        Y <- model.extract(X, "response")
        if (!inherits(Y, "Surv")) 
            stop("response variable should be a Surv object")
        n <- nrow(Y)
        weights <- model.extract(X, "weights")
        offset <- attr(X, "offset")
        if (!xpres) {
            X <- matrix(nrow = 0, ncol = 0)
            assign <- NULL
        }
        else {
            X <- model.matrix(sformula, X)
            alt <- attr(mmcolnames, "alt")
            if (debug) {
                print(cbind(`colnames(X)` = colnames(X)[-1], mmcolnames = mmcolnames, `Design colnames` = atr$colnames, alt = alt))
            }
            if (!all(mmcolnames %in% colnames(X)) && length(alt)) 
                mmcolnames <- alt
            X <- X[, mmcolnames, drop = FALSE]
            assign <- attr(X, "assign")
            assign[[1]] <- NULL
        }
        nullmod <- FALSE
    }
    else {
        X <- NULL
        Y <- data[[1]]
        sformula <- formula
        mmcolnames <- ""
        weights <- if ("(weights)" %in% names(data)) 
            data[["(weights)"]]
        atr <- atrx <- NULL
        Terms <- terms(formula, allowDotAsName = TRUE)
        if (!inherits(Y, "Surv")) 
            stop("response variable should be a Surv object")
        Y <- Y[!is.na(Y)]
        assign <- NULL
        xpres <- FALSE
        nullmod <- TRUE
        nact <- NULL
    }
    ny <- ncol(Y)
    maxtime <- max(Y[, ny - 1])
    rnam <- if (!nonames) 
        dimnames(Y)[[1]]
    if (xpres) 
        dimnames(X) <- list(rnam, atr$colnames)
    if (method == "model.matrix") 
        return(X)
    time.units <- units(Y)
    if (!length(time.units) || time.units == "") 
        time.units <- "Day"
    if (missing(time.inc)) {
        time.inc <- switch(time.units, Day = 30, Month = 1, Year = 1, maxtime/10)
        if (time.inc >= maxtime | maxtime/time.inc > 25) 
            time.inc <- max(pretty(c(0, maxtime)))/10
    }
    ytype <- attr(Y, "type")
    if (nullmod) 
        f <- NULL
    else {
        fitter <- if (method == "breslow" || method == "efron") {
            if (ytype == "right") 
                coxph.fit
            else agreg.fit
        }
        else if (method == "exact") {
            if (ytype == "right") 
                getFromNamespace("coxexact.fit", "survival")
            else agexact.fit
        }
        else stop(paste("Unknown method", method))
        if (missing(init)) 
            init <- NULL
        f <- fitter(X, Y, strata = Strata, offset = offset, weights = weights, init = init, method = method, rownames = rnam, control = coxph.control(eps = eps, toler.chol = tol, toler.inf = 1, iter.max = iter.max))
    }
    if (is.character(f)) {
        cat("Failure in cph:\n", f, "\n")
        return(structure(list(fail = TRUE), class = "cph"))
    }
    else {
        if (length(f$coefficients) && any(is.na(f$coefficients))) {
            vars <- names(f$coefficients)[is.na(f$coefficients)]
            msg <- paste("X matrix deemed to be singular; variable", paste(vars, collapse = " "))
            if (singular.ok) 
                warning(msg)
            else {
                cat(msg, "\n")
                return(structure(list(fail = TRUE), class = "cph"))
            }
        }
    }
    f$terms <- Terms
    f$sformula <- sformula
    f$mmcolnames <- mmcolnames
    if (robust) {
        f$naive.var <- f$var
        if (!length(cluster)) 
            cluster <- FALSE
        fit2 <- c(f, list(x = X, y = Y, weights = weights, method = method))
        if (length(stra)) 
            fit2$strata <- Strata
        r <- getS3method("residuals", "coxph")(fit2, type = "dfbeta", collapse = cluster, weighted = TRUE)
        f$var <- t(r) %*% r
    }
    nvar <- length(f$coefficients)
    ev <- factor(Y[, ny], levels = 0:1, labels = c("No Event", "Event"))
    n.table <- {
        if (!length(Strata)) 
            table(ev, dnn = "Status")
        else table(Strata, ev, dnn = c("Stratum", "Status"))
    }
    f$n <- n.table
    nevent <- sum(Y[, ny])
    if (xpres) {
        logtest <- -2 * (f$loglik[1] - f$loglik[2])
        R2.max <- 1 - exp(2 * f$loglik[1]/n)
        R2 <- (1 - exp(-logtest/n))/R2.max
        P <- 1 - pchisq(logtest, nvar)
        gindex <- GiniMd(f$linear.predictors)
        dxy <- dxy.cens(f$linear.predictors, Y, type = "hazard")["Dxy"]
        stats <- c(n, nevent, logtest, nvar, P, f$score, 1 - pchisq(f$score, nvar), R2, dxy, gindex, exp(gindex))
        names(stats) <- c("Obs", "Events", "Model L.R.", "d.f.", "P", "Score", "Score P", "R2", "Dxy", "g", "gr")
    }
    else {
        stats <- c(n, nevent)
        names(stats) <- c("Obs", "Events")
    }
    f$method <- NULL
    if (xpres) 
        dimnames(f$var) <- list(atr$colnames, atr$colnames)
    f <- c(f, list(call = call, Design = atr, assign = DesignAssign(atr, 0, atrx$terms), na.action = nact, fail = FALSE, non.slopes = 0, stats = stats, method = method, maxtime = maxtime, time.inc = time.inc, units = time.units))
    if (xpres) {
        f$center <- sum(f$means * f$coefficients)
        f$scale.pred <- c("log Relative Hazard", "Hazard Ratio")
        attr(f$linear.predictors, "strata") <- Strata
        names(f$linear.predictors) <- rnam
        if (se.fit) {
            XX <- X - rep(f$means, rep.int(n, nvar))
            se.fit <- drop(((XX %*% f$var) * XX) %*% rep(1, ncol(XX)))^0.5
            names(se.fit) <- rnam
            f$se.fit <- se.fit
        }
    }
    if (model) 
        f$model <- data
    if (is.character(surv) || surv) {
        if (length(Strata)) {
            iStrata <- as.character(Strata)
            slev <- levels(Strata)
            nstr <- length(slev)
        }
        else nstr <- 1
        srv <- NULL
        tim <- NULL
        s.e. <- NULL
        timepts <- seq(0, maxtime, by = time.inc)
        s.sum <- array(double(1), c(length(timepts), nstr, 3), list(format(timepts), paste("Stratum", 1:nstr), c("Survival", "n.risk", "std.err")))
        g <- list(n = sum(f$n), coefficients = f$coefficients, linear.predictors = f$linear.predictors, method = f$method, type = type, means = f$means, var = f$var, x = X, y = Y, strata = Strata, offset = offset, weights = weights, terms = Terms, call = call)
        g <- survfit.cph(g, se.fit = is.character(surv) || surv, type = type, vartype = vartype, conf.type = "log")
        strt <- if (nstr > 1) 
            rep(names(g$strata), g$strata)
        for (k in 1:nstr) {
            j <- if (nstr == 1) 
                TRUE
            else strt == slev[k]
            yy <- Y[if (nstr == 1) 
                TRUE
            else iStrata == slev[k], ny - 1]
            maxt <- max(yy)
            tt <- c(0, g$time[j])
            su <- c(1, g$surv[j])
            se <- c(NA, g$std.err[j])
            if (maxt > tt[length(tt)]) {
                tt <- c(tt, maxt)
                su <- c(su, su[length(su)])
                se <- c(se, NA)
            }
            kk <- 0
            for (tp in timepts) {
                kk <- kk + 1
                t.choice <- max((1:length(tt))[tt <= tp + 1e-06])
                if (tp > max(tt) + 1e-06 & su[length(su)] > 0) {
                  Su <- NA
                  Se <- NA
                }
                else {
                  Su <- su[t.choice]
                  Se <- se[t.choice]
                }
                n.risk <- sum(yy >= tp)
                s.sum[kk, k, 1:3] <- c(Su, n.risk, Se)
            }
            if (!is.character(surv)) {
                if (nstr == 1) {
                  tim <- tt
                  srv <- su
                  s.e. <- se
                }
                else {
                  tim <- c(tim, list(tt))
                  srv <- c(srv, list(su))
                  s.e. <- c(s.e., list(se))
                }
            }
        }
        if (is.character(surv)) 
            f$surv.summary <- s.sum
        else {
            if (nstr > 1) {
                names(srv) <- names(tim) <- names(s.e.) <- levels(Strata)
            }
            f <- c(f, list(time = tim, surv = srv, std.err = s.e., surv.summary = s.sum))
        }
    }
    f$strata <- Strata
    if (x) 
        f$x <- X
    if (y) 
        f$y <- Y
    f$weights <- weights
    f$offset <- offset
    if (!linear.predictors) 
        f$linear.predictors <- NULL
    if (!residuals) 
        f$residuals <- NULL
    class(f) <- c("cph", "rms", "coxph")
    f
}() 

Summary of the weights  G(T_i-|X_i) :

   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.0393  0.6206  0.7942  0.7388  0.9160  1.0000 
> plot(WCox$weights,WKM$weights)
> 
> # using the stratified Kaplan-Meier for the censoring times given X2
> 
> WKM2 <- subjectWeights(Surv(time,status)~X2,data=dat,method="nonpar")
> plot(WKM2$fit,add=FALSE)
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’, ‘package:prodlim’

> nameEx("subsetIndex")
> ### * subsetIndex
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: subsetIndex
> ### Title: Extract Specific Elements From An Object
> ### Aliases: subsetIndex subsetIndex.default subsetIndex.matrix
> 
> ### ** Examples
> 
> M <- matrix(rnorm(50),5,10)
> subsetIndex(M, index = c(0,0,1), default = 0)
     [,1] [,2]       [,3]
[1,]    0    0 -0.6264538
[2,]    0    0  0.1836433
[3,]    0    0 -0.8356286
[4,]    0    0  1.5952808
[5,]    0    0  0.3295078
> subsetIndex(M, index = c(0,2,3,NA), default = 0)
     [,1]       [,2]       [,3] [,4]
[1,]    0 -0.8204684  1.5117812   NA
[2,]    0  0.4874291  0.3898432   NA
[3,]    0  0.7383247 -0.6212406   NA
[4,]    0  0.5757814 -2.2146999   NA
[5,]    0 -0.3053884  1.1249309   NA
> subsetIndex(M, index = c(0,NA,2,3,NA), default = 0)
     [,1] [,2]       [,3]       [,4] [,5]
[1,]    0   NA -0.8204684  1.5117812   NA
[2,]    0   NA  0.4874291  0.3898432   NA
[3,]    0   NA  0.7383247 -0.6212406   NA
[4,]    0   NA  0.5757814 -2.2146999   NA
[5,]    0   NA -0.3053884  1.1249309   NA
> 
> C <- 1:10
> subsetIndex(C, index = c(0,0,1,5,NA), default = 0)
[1]  0  0  1  5 NA
> 
> 
> 
> cleanEx()
> nameEx("wglm")
> ### * wglm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: wglm
> ### Title: Logistic Regression Using IPCW
> ### Aliases: wglm
> 
> ### ** Examples
> 
> library(survival)
> 
> set.seed(10)
> n <- 250
> tau <- 1:5
> d <- sampleData(n, outcome = "competing.risks")
> d$Y <- (d$event == 1)*(d$time <= tau[3])
> d0 <- d[event!=0] ## remove censoring
> 
> ## no censoring
> e0.wglm <- wglm(regressor.event = ~ X1, formula.censor = Surv(time,event==0) ~ X1,
+                times = tau, data = d0)
> e0.glm <- glm(Y ~ X1, family = binomial, data = d0)
> 
> ## censoring
> e.wglm <- wglm(regressor.event = ~ X1, formula.censor = Surv(time,event==0) ~ X1,
+                times = tau, data = d)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:survival’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  33.343 1.256 36.548 0.002 0.005 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
