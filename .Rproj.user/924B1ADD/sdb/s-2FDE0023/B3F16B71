{
    "collab_server" : "",
    "contents" : "#' Create case-base dataset for use in fitting parametric hazard functions\n#'\n#' This function implements the case-base sampling approach described in Hanley\n#' and Miettinen, Int J Biostatistics 2009. It can be used to fit smooth-in-time\n#' parametric functions easily, via logistic regression.\n#'\n#' It is assumed that \\code{data} contains the two columns corresponding to the\n#' supplied time and event variables. If either the \\code{time} or \\code{event}\n#' argument is missing, the function looks for columns named \\code{\"time\"},\n#' \\code{\"event\"}, or \\code{\"status\"}.\n#'\n#' @param data a data.frame or data.table containing the source dataset.\n#' @param time a character string giving the name of the time variable. See\n#'   Details.\n#' @param event a character string giving the name of the event variable. See\n#'   Details.\n#' @param ratio Integer, giving the ratio of the size of the base series to that\n#'   of the case series. Defaults to 10.\n#' @param type There are currently two sampling procedures available:\n#'   \\code{uniform}, where person-moments are sampled uniformly across\n#'   individuals and follow-up time; and \\code{multinomial}, where individuals\n#'   are sampled proportionally to their follow-up time.\n#' @return The function returns a dataset, with the same format as the source\n#'   dataset, and where each row corresponds to a person-moment sampled from the\n#'   case or the base series. otherwise)\n#' @export\nsampleCaseBase <- function(data, time, event, ratio = 10, type = c(\"uniform\", \"multinomial\")) {\n    if (missing(time)) {\n        if (\"time\" %in% colnames(data)) {\n            time <- \"time\"\n        } else {\n            stop(\"data does not contain time variable\")\n        }\n    }\n    if (missing(event)) {\n        if (\"event\" %in% colnames(data)) {\n            event <- \"event\"\n        } else {\n            if (\"status\" %in% colnames(data)) {\n                event <- \"status\"\n            } else {\n                stop(\"data does not contain event or status variable\")\n            }\n        }\n    }\n    if (!all(c(time, event) %in% colnames(data))) {\n        stop(\"data does not contain supplied time and event variables\")\n    }\n    type <- match.arg(type)\n    # Create survival object from dataset\n    survObj <- survival::Surv(subset(data, select=(names(data) == time)),\n                              subset(data, select=(names(data) == event)))\n\n    n <- nrow(survObj) # no. of subjects\n    B <- sum(survObj[, \"time\"])             # total person-time in base\n    c <- sum(survObj[, \"status\"])          # no. of cases (events)\n    b <- ratio * c               # size of base series\n    offset <- log(B / b)            # offset so intercept = log(ID | x, t = 0 )\n\n    if (type == \"uniform\") {\n        # The idea here is to sample b individuals, with replacement, and then\n        # to sample uniformly a time point for each of them. The sampled time\n        # point must lie between the beginning and the end of follow-up\n        p <- survObj[, \"time\"]/B\n        who <- sample(n, b, replace = TRUE, prob = p)\n        bSeries <- as.matrix(survObj[who, ])\n        bSeries[, \"status\"] <- 0\n        bSeries[, \"time\"] <- runif(b) * bSeries[, \"time\"]\n    }\n\n    if (type == \"multinomial\") {\n        # Multinomial sampling: probability of individual contributing a\n        # person-moment to base series is proportional to time variable\n        # dt <- B/(b+1)\n        # pSum <- c(0) #Allocate memory first!!\n        # for (i in 1:n) {\n        #     pSum <- c(pSum, pSum[i] + survObj[i, \"time\"])\n        # }\n        pSum <- c(0, cumsum(survObj[, \"time\"]))\n        everyDt <- B*(1:b)/(b+1)\n        who <- findInterval(everyDt, pSum)\n        bSeries <- as.matrix(survObj[who, ])\n        bSeries[, \"status\"] <- 0\n        bSeries[, \"time\"] <- everyDt - pSum[who]\n    }\n\n    # Next commented line will break on data.table\n    # bSeries <- cbind(bSeries, data[who, colnames(data) != c(\"time\", \"event\")])\n    bSeries <- cbind(bSeries, subset(data, select = (colnames(data) != c(time, event)))[who,])\n    names(bSeries)[names(bSeries) == \"status\"] <- event\n\n    cSeries <- data[which(subset(data, select=(names(data) == event)) == 1),]\n    # cSeries <- survObj[survObj[, \"status\"] == 1, ]\n    # cSeries <- cSeries[, c(i.var, id.var, x.vars, time)]\n    # cSeries$y <- 1\n    # cSeries[, time] <- cSeries[, time]\n\n    # Combine case and base series\n    cbSeries <- rbind(cSeries, bSeries)\n    # Add offset to dataset\n    cbSeries <- cbind(cbSeries, rep_len(offset, nrow(cbSeries)))\n    names(cbSeries)[ncol(cbSeries)] <- \"offset\"\n\n    class(cbSeries) <- c(\"cbData\", class(cbSeries))\n    return(cbSeries)\n}\n",
    "created" : 1452462173214.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1481182578",
    "id" : "B3F16B71",
    "lastKnownWriteTime" : 1452461920,
    "last_content_update" : 1452461920,
    "path" : "~/git_repositories/casebase/R/sampling.R",
    "project_path" : "R/sampling.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}