% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/absoluteRisk-cr.R, R/absoluteRisk.R
\name{absoluteRisk.CompRisk}
\alias{absoluteRisk.CompRisk}
\alias{absoluteRisk}
\title{Compute absolute risks using the fitted hazard function.}
\usage{
absoluteRisk.CompRisk(
  object,
  time,
  newdata,
  method = c("numerical", "montecarlo"),
  nsamp = 100,
  onlyMain = TRUE,
  type = c("CI", "survival"),
  addZero = TRUE
)

absoluteRisk(
  object,
  time,
  newdata,
  method = c("numerical", "montecarlo"),
  nsamp = 100,
  s = c("lambda.1se", "lambda.min"),
  n.trees,
  onlyMain = TRUE,
  type = c("CI", "survival"),
  addZero = TRUE,
  ...
)
}
\arguments{
\item{object}{Output of function \code{\link{fitSmoothHazard}}.}

\item{time}{A vector of time points at which we should compute the absolute
risks.}

\item{newdata}{Optionally, a data frame in which to look for variables with
which to predict. If omitted, the mean absolute risk is returned.}

\item{method}{Method used for integration. Defaults to \code{"numerical"},
which uses the trapezoidal rule to integrate over all time points together.
The only other option is \code{"montecarlo"}, which implements Monte-Carlo
integration.}

\item{nsamp}{Maximal number of subdivisions (if \code{method = "numerical"})
or number of sampled points (if \code{method = "montecarlo"}).}

\item{onlyMain}{Logical. For competing risks, should we return absolute risks
only for the main event of interest? Defaults to \code{TRUE}.}

\item{type}{Type of output. Can be \code{"CI"} (output is on the cumulative
incidence scale) or \code{"survival"} (output is on the survival scale,
i.e. 1- CI)}

\item{addZero}{Logical. Should we add time = 0 at the beginning of the
output? Defaults to \code{TRUE}.}

\item{s}{Value of the penalty parameter lambda at which predictions are
required (for class \code{cv.glmnet}).}

\item{n.trees}{Number of trees used in the prediction (for class \code{gbm}).}

\item{...}{Extra parameters. Currently these are simply ignored.}
}
\value{
If \code{time} was provided, returns the estimated absolute risk for
the user-supplied covariate profiles. This will be stored in a 2- or
3-dimensional array, depending on the input (see details). If both
\code{time} and \code{newdata} were provided, returns the original data
with a new column containing the risk estimate at failure time.
}
\description{
Using the output of the function \code{fitSmoothHazard}, we can compute
absolute risks by integrating the fitted hazard function over a time period
and then converting this to an estimated survival for each individual.
}
\details{
If the user supplies the original dataset through the parameter
\code{newdata}, the mean absolute risk can be computed as the average of the
output vector.

In general, if \code{time} is a vector of length greater than one, the output
will include a column corresponding to the provided time points. Some
modifications of the \code{time} vector are done: \code{time=0} is added, the
time points are ordered, and duplicates are removed. All these modifications
simplify the computations and give an output that can easily be used to plot
risk curves.

On the other hand, if \code{time} corresponds to a single time point, the
output does not include a column corresponding to time.

If there is no competing risk, the output is a matrix where each column
corresponds to the several covariate profiles, and where each row corresponds
to a time point. If there are competing risks, the output will be a
3-dimensional array, with the third dimension corresponding to the different
events.

The numerical method should be good enough in most situation, but Monte Carlo
integration can give more accurate results when the estimated hazard function
is not smooth (e.g. when modeling with time-varying covariates).
z
}
\examples{
# Simulate censored survival data for two outcome types from exponential distributions
library(data.table)
set.seed(12345)
nobs <- 1000
tlim <- 20

# simulation parameters
b1 <- 200
b2 <- 50

# event type 0-censored, 1-event of interest, 2-competing event
# t observed time/endpoint
# z is a binary covariate
DT <- data.table(z=rbinom(nobs, 1, 0.5))
DT[,`:=` ("t_event" = rweibull(nobs, 1, b1),
          "t_comp" = rweibull(nobs, 1, b2))]
DT[,`:=`("event" = 1 * (t_event < t_comp) + 2 * (t_event >= t_comp),
         "time" = pmin(t_event, t_comp))]
DT[time >= tlim, `:=`("event" = 0, "time" = tlim)]

out_linear <- fitSmoothHazard(event ~ time + z, DT, ratio = 10)

linear_risk <- absoluteRisk(out_linear, time = 10, newdata = data.table("z"=c(0,1)))
}
